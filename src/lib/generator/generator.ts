import type {
  FieldDefinition,
  ModelDefinition,
  FullSettings
} from '$lib/types.js';
import { join,relative, extname, basename } from 'path';
import fs from 'fs-extra';
import { fmtPath, prettify, wait } from '$lib/cli/utils.js';


const GENERATED_CODE_FILENAMES = {
  modelTypes: 'types.ts',
  database: 'database.ts',
  schemaCast: 'schema-cast.ts',
  modelDefinitions: 'model-definitions.ts'
}

const SCHEMA_CAST_CONST_NAME = 'schemaCast';
export const writeAll = async (
  models: ModelDefinition[],
  settings: FullSettings
): Promise<void> => {
  const bannerComment = `
    /**
     * Generated by frieda on ${new Date().toUTCString()}
     * Run \`frieda g\` to regenerate.
     */ 
  `;
  
  await writeModelDefinitionsTs(models, settings, bannerComment)
  await writeModelsDTs(models, settings, bannerComment);
  await writeSchemaCastsTs(models, settings, bannerComment);
  await writeDatabaseTs(models, settings, bannerComment)
};

const writeModelDefinitionsTs =async (
  models: ModelDefinition[],
  settings: FullSettings,
  bannerComment: string
) => {
  const filePath = join(
    process.cwd(),
    settings.generatedCodeDirectory,
    GENERATED_CODE_FILENAMES.modelDefinitions
  );
  const s = wait(`Generating ${fmtPath(relative(process.cwd(), filePath))}`);
  const ts = `
    ${bannerComment}

    import type { ModelDefinition } from '@nowzoo/frieda';

    ${models.map(m => {
      return `export const ${m.modelDefinitionConstName}: ModelDefinition = ${JSON.stringify(m)}`
    }).join('\n\n')}
  `
  const prettified = await prettify(ts, filePath);
  await fs.ensureFile(filePath);
  await fs.writeFile(filePath, prettified);
  s.done();
}

const writeSchemaCastsTs = async (
  models: ModelDefinition[],
  settings: FullSettings,
  bannerComment: string
) => {
  const filePath = join(
    process.cwd(),
    settings.generatedCodeDirectory,
    GENERATED_CODE_FILENAMES.schemaCast
  );
  const s = wait(`Generating ${fmtPath(relative(process.cwd(), filePath))}`);
  const ts = `
    ${bannerComment}
    import type { SchemaCast } from '@nowzoo/frieda';
   
    export const ${SCHEMA_CAST_CONST_NAME} : SchemaCast = {
      ${models
        .flatMap((m) => {
          return m.fields.map(
            (f) => `'${m.tableName}.${f.columnName}': '${f.castType}'`
          );
        })
        .join(',\n')}
    }
  `;
  
  const prettified = await prettify(ts, filePath);
  await fs.ensureFile(filePath);
  await fs.writeFile(filePath, prettified);
  s.done();
};

/**
 * Get the typescript code for <generatedCodeDirectory>/models.d.ts.
 */
const writeModelsDTs = async (
  models: ModelDefinition[],
  settings: FullSettings,
  bannerComment: string
): Promise<void> => {
  const filePath = join(
    process.cwd(),
    settings.generatedCodeDirectory,
    GENERATED_CODE_FILENAMES.modelTypes
  );
  const s = wait(`Generating ${fmtPath(relative(process.cwd(), filePath))}`);
  const types = models.map((m) => generateModelTypes(m)).join('\n');

  const ts = `
    ${bannerComment}
    
    import type {ModelRepo} from '@nowzoo/frieda';
    ${(settings.externalTypeImports || []).join('\n')}

    ${types}
  `;
  const prettified = await prettify(ts, filePath);
  await fs.ensureFile(filePath);
  await fs.writeFile(filePath, prettified);
  s.done();
};

const writeDatabaseTs = async (
  models: ModelDefinition[],
  settings: FullSettings,
  bannerComment: string
): Promise<void> => {
  const filePath = join(
    process.cwd(),
    settings.generatedCodeDirectory,
    GENERATED_CODE_FILENAMES.database
  );
  const s = wait(`Generating ${fmtPath(relative(process.cwd(), filePath))}`);
  
  const ts = `
  ${bannerComment}

  import type { Connection, Transaction } from '@planetscale/database';
  import { AbstractDb, ModelRepo, type DbLoggingOptions } from '@nowzoo/frieda';
  import type {
    ${
      models.map(m => m.modelRepoTypeName).join(',\n')
    }
  } from './${basename(GENERATED_CODE_FILENAMES.modelTypes, extname(GENERATED_CODE_FILENAMES.modelTypes))}.js'
  import {
    ${
      models.map(m => m.modelDefinitionConstName).join(',\n')
    }
  } from './${basename(GENERATED_CODE_FILENAMES.modelDefinitions, extname(GENERATED_CODE_FILENAMES.modelDefinitions))}.js'

  import {
    ${SCHEMA_CAST_CONST_NAME}
  } from './${basename(GENERATED_CODE_FILENAMES.schemaCast, extname(GENERATED_CODE_FILENAMES.schemaCast))}.js'

  export abstract class ReposDb extends AbstractDb {
    
    private repos: Partial<{
      ${
        models.map(m => {
          return `${m.classRepoName}: ${m.modelRepoTypeName};`
        }).join('\n')
      }
    }> = {};

    constructor(
      connOrTx: Connection | Transaction,
      loggingOptions: DbLoggingOptions = {}
    ) {
      super(connOrTx, ${SCHEMA_CAST_CONST_NAME}, loggingOptions)
    }

    ${
      models.map(m => {
        return `get ${m.classRepoName} (): ${m.modelRepoTypeName} {
          if (! this.repos.${m.classRepoName}) {
            this.repos.${m.classRepoName} = new ModelRepo(
              ${m.modelDefinitionConstName}, 
              this.connection, 
              this.schemaCast, 
              this.loggingOptions
            )
          }
          return this.repos.${m.classRepoName};
        }`
      }).join('\n\n')
    }
  }

  export class TxDb extends ReposDb {
    constructor(
      transaction: Transaction,
      loggingOptions: DbLoggingOptions = {}
    ){
      super(transaction, loggingOptions)
    }
  }
  

  export class AppDb extends ReposDb {
    constructor(private conn: Connection, loggingOptions: DbLoggingOptions = {}) {
      super(conn, loggingOptions);
    }
  
    async transaction<T>(txFn: (txDb: TxDb) => Promise<T>) {
      const result = await this.conn.transaction(async (tx) => {
        const txDb = new TxDb(tx, this.loggingOptions);
        return await txFn(txDb);
      });
      return result;
    }
  }
  `
  const prettified = await prettify(ts, filePath);
  await fs.ensureFile(filePath);
  await fs.writeFile(filePath, prettified);
  s.done();
}

export const generateModelTypes = (model: ModelDefinition): string => {
  const modelType = `export type ${model.modelName}={${model.fields
    .map((f) => getModelFieldTypeDef(f))
    .join(`\n`)}}`;
  const primaryKeyType = `export type ${model.modelPrimaryKeyTypeName} = {
    ${model.fields
      .filter((f) => f.isColumnPrimaryKey)
      .map((f) => {
        return `${f.fieldName}: ${f.javascriptType};`;
      })
      .join('\n')}
  }`;

  const modelCreateDataType = `export type ${
    model.modelCreateDataTypeName
  }={${model.fields
    .map((f) => getModelCreateDataFieldTypeDef(f))
    .filter((s) => s !== null)
    .join(`\n`)}}`;
  const modelUpdateDataType = `export type ${
    model.modelUpdateDataTypeName
  }={${model.fields
    .map((f) => getModelUpdateDataFieldTypeDef(f))
    .filter((s) => s !== null)
    .join(`\n`)}}`;

  const modelFindUniqueType = `export type ${
    model.modelFindUniqueParamsTypeName
  } = ${[
    model.modelPrimaryKeyTypeName,
    ...model.fields
      .filter((f) => f.isColumnUnique)
      .map((f) => `{${f.fieldName}:${f.javascriptType}}`)
  ].join('|')}`;

  const modelRepoType = `export type ${model.modelRepoTypeName} = ModelRepo<
    ${model.modelName}, 
    ${model.modelPrimaryKeyTypeName},
    ${model.modelCreateDataTypeName},
    ${model.modelUpdateDataTypeName},
    ${model.modelFindUniqueParamsTypeName}
  >`;

  return `
  /**
   * Types for the ${model.modelName} model
   */
  ${modelType}
  ${primaryKeyType}
  ${modelCreateDataType}
  ${modelUpdateDataType}
  ${modelFindUniqueType}
  ${modelRepoType}
  `;
};



/**
 * The type definition string for inclusion in the base type of a model.
 * including whether it is possibly undefined and/or null.
 *
 * The resulting string is:
 *
 * `<field.fieldName>[?]: <field.javscriptType>[|null];`
 *
 *
 *
 * A question mark after the name means that field.isInvisible is true,
 * so the field will be `undefined` unless specifically selected.
 *
 * `|null` after the javascript type means that the field can be null: field.isColumnNullable.
 */
export const getModelFieldTypeDef = (field: FieldDefinition): string => {
  // Don't add any whitespace; it'll break tests; prettier will format.
  return `${field.fieldName}${field.isColumnInvisible ? '?' : ''}:${
    field.javascriptType
  }${field.isColumnNullable ? '|null' : ''}`;
};

/**
 * The type definition string for inclusion in the "create data" type of a model.
 */
export const getModelCreateDataFieldTypeDef = (
  field: FieldDefinition
): string | null => {
  if (field.isColumnAlwaysGenerated) {
    // then it's not included
    return null;
  }

  const isOptional =
    field.isColumnAutoIncrement || field.isColumnDefaultGenerated;
  // Don't add any whitespace; it'll break tests; prettier will format.
  return `${field.fieldName}${isOptional ? '?' : ''}:${field.javascriptType}${
    field.isColumnNullable ? '|null' : ''
  }`;
};

/**
 * The type definition string for inclusion in the "update data" type of a model.
 */
export const getModelUpdateDataFieldTypeDef = (
  field: FieldDefinition
): string | null => {
  if (field.isColumnAlwaysGenerated) {
    // then it's not included
    return null;
  }
  if (field.isColumnPrimaryKey) {
    // then it's not included
    return null;
  }
  // Don't add any whitespace; it'll break tests; prettier will format.
  return `${field.fieldName}?:${field.javascriptType}${
    field.isColumnNullable ? '|null' : ''
  }`;
};
