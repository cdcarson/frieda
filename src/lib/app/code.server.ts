import type {
  FieldDefinition,
  FullTextSearchIndex,
  ModelDefinition,
  SchemaCastMap,
  SchemaDefinition
} from '$lib/index.js';
import {
  DEFAULT_PRETTIER_OPTIONS,
  type AppOptions,
  type FileResult,
  type ParsedSchema,
  CODE_FILE_BASENAMES,
  type CodeFiles,
  TS_COMPILER_OPTIONS,
  type ModelTypeData
} from './shared.js';
import { basename, extname, join } from 'node:path';
import prettier from 'prettier';
import { Project } from 'ts-morph';
import { getFileResult, saveFile } from './fs.server.js';
import { tsquery } from '@phenomnomnominal/tsquery';
import ts from  'typescript'
export const getTypescriptFileNames = (): string[] => {
  return CODE_FILE_BASENAMES.map((f) => `${f}.ts`);
};
export const getJavascriptFileNames = (): string[] => {
  return CODE_FILE_BASENAMES.flatMap((f) => {
    if (f === 'types.d') {
      return ['types.d.ts'];
    }
    return [`${f}.js`, `${f}.d.ts`];
  });
};

export const getModelTypes = (schema: ParsedSchema, codeFiles: CodeFiles): ModelTypeData[] => {
  const typesDContent = codeFiles.files['types.d'][0].contents || '';
  const ast = tsquery.ast(typesDContent);
  const nodes: ts.TypeAliasDeclaration[] = tsquery(ast, 'TypeAliasDeclaration');
  return nodes.map(node => {
    return {
      name: node.name.getText(),
      pos: ts.getLineAndCharacterOfPosition(ast, node.getStart()),
      fullText: node.getFullText(),
      text: node.getText()
    }
  });
}

export const createCodeFilesResult = (fileResults: FileResult[]): CodeFiles => {
  const codeFiles: CodeFiles = {
    files: {
      database: fileResults.filter(
        (f) => basename(f.basename, f.extname) === 'database'
      ),
      schema: fileResults.filter(
        (f) => basename(f.basename, f.extname) === 'schema'
      ),
      'search-indexes': fileResults.filter(
        (f) => basename(f.basename, f.extname) === 'search-indexes'
      ),
      'types.d': fileResults.filter(
        (f) => basename(f.basename, f.extname) === 'types.d'
      )
    },
    valid: true,
  };
  for (const f of fileResults) {
    if (!f.exists || !f.isFile || !f.contents) {
      codeFiles.valid = false;
    }
  }

  return codeFiles;
}

export const readSourceCodeFiles = async (
  options: AppOptions
): Promise<CodeFiles> => {
  const baseNamesWithExt = options.compileJs
    ? getJavascriptFileNames()
    : getTypescriptFileNames();
  const fileResults = await Promise.all(
    baseNamesWithExt.map((filename) => {
      return getFileResult(options, join(options.outputDirectory, filename));
    })
  );
  return createCodeFilesResult(fileResults)
 
};

export const generateSourceCodeFiles = async (
  schema: ParsedSchema,
  options: AppOptions
): Promise<CodeFiles> => {
  const bannerComment = `
    /**
     * Generated by Frieda on ${new Date().toUTCString()}
     * Run \`frieda g\` to re-generate.
     */
  `;

  const tsPrettierOpts = { ...DEFAULT_PRETTIER_OPTIONS, filepath: 'x.ts' };

  const typesDSourceCode = prettier.format(
    getTypesDSourceCode(schema, bannerComment),
    tsPrettierOpts
  );
  type GenFile = {
    basename: (typeof CODE_FILE_BASENAMES)[number];
    filename: string;
    contents: string;
  };
  let files: GenFile[];

  const tsFiles: GenFile[] = [
    {
      basename: 'database',
      filename: 'database.ts',
      contents: prettier.format(
        getDatabaseSourceCode(schema, bannerComment),
        tsPrettierOpts
      )
    },
    {
      basename: 'schema',
      filename: 'schema.ts',
      contents: prettier.format(
        getSchemaSourceCode(schema, bannerComment),
        tsPrettierOpts
      )
    },
    {
      basename: 'search-indexes',
      filename: 'search-indexes.ts',
      contents: prettier.format(
        getSearchIndexesSourceCode(schema, bannerComment),
        tsPrettierOpts
      )
    },
    {
      basename: 'types.d',
      filename: 'types.d.ts',
      contents: typesDSourceCode
    }
  ];
  if (options.compileJs) {
    const project = new Project({
      compilerOptions: TS_COMPILER_OPTIONS
    });
    tsFiles.forEach((f) => {
      project.createSourceFile(f.basename + '.ts', f.contents, {
        overwrite: true
      });
    });
    const jsFiles: GenFile[] = project
      .emitToMemory()
      .getFiles()
      .map((f) => {
        const b = basename(f.filePath);
        const contents = ['.js', '.ts'].includes(extname(b))
          ? prettier.format(f.text, {
              ...DEFAULT_PRETTIER_OPTIONS,
              filepath: f.filePath
            })
          : f.text;
        return {
          basename: basename(
            b,
            extname(b)
          ) as (typeof CODE_FILE_BASENAMES)[number],
          filename: f.filePath,
          contents
        };
      });
    jsFiles.push({ basename: 'types.d', filename: 'types.d.ts',  contents: typesDSourceCode });
    files = jsFiles;
  } else {
    files = tsFiles;
  }
  const fileResults = await Promise.all(
    files.map((f) => {
      return saveFile(
        options,
        join(options.outputDirectory, f.filename),
        f.contents
      );
    })
  );
  return createCodeFilesResult(fileResults)
};

export const getDatabaseSourceCode = (
  schema: ParsedSchema,
  bannerComment: string
): string => {
  return `
    ${bannerComment}
    import type { Transaction, Connection } from '@planetscale/database';
    import { BaseDb, ModelDb, type DbLoggingOptions, type Schema } from '@nowzoo/frieda';
    import schema from './schema.js';
    import type {
      ${schema.models.map((m) => m.dbTypeName).join(',')}
    } from './types.js';
    export abstract class ModelsDb extends BaseDb {
      private models: Partial<{
        ${schema.models
          .map((m) => {
            return `${m.appDbKey}: ${m.dbTypeName}`;
          })
          .join('\n')}
      }>;

      constructor(
        conn: Connection | Transaction,
        schema: Schema,
        loggingOptions: DbLoggingOptions = {}
      ) {
        super(conn, schema, loggingOptions);
        this.models = {};
      }

      ${schema.models
        .map((m) => {
          return `
            get ${m.appDbKey}(): ${m.dbTypeName} {
              if (! this.models.${m.appDbKey}) {
                this.models.${m.appDbKey} = new ModelDb('${m.modelName}', this.connOrTx, schema, this.loggingOptions)
              }
              return this.models.${m.appDbKey} 
            }
          `;
        })
        .join('\n')}
    }

    export class TxDb extends ModelsDb {
      constructor(
        transaction: Transaction,
        loggingOptions: DbLoggingOptions = {}
      ) {
        super(transaction, schema, loggingOptions)
      }
    }

    export class AppDb extends ModelsDb {
      #conn: Connection;
      constructor(
        connection: Connection,
        loggingOptions: DbLoggingOptions = {}
      ) {
        super(connection, schema, loggingOptions);
        this.#conn = connection;
      }
      async transaction<T>(txFn: (txDb: TxDb) => Promise<T>) {
        const result = await this.#conn.transaction(async (tx) => {
          const txDb = new TxDb(tx, this.loggingOptions);
          return await txFn(txDb);
        });
        return result;
      }
    }
  `;
};

export const getSearchIndexesSourceCode = (
  schema: ParsedSchema,
  bannerComment: string
): string => {
  const map: { [key: string]: FullTextSearchIndex } = schema.models.reduce(
    (acc, m) => {
      const copy = { ...acc };
      const indexes = m.indexes.filter((i) => i.isFullTextSearch);
      indexes.forEach((i) => {
        const fi: FullTextSearchIndex = {
          indexedFields: i.indexedColumns,
          key: i.indexName,
          tableName: m.tableName
        };
        copy[fi.key] = fi;
      });
      return copy;
    },
    {} as { [key: string]: FullTextSearchIndex }
  );

  return `
      ${bannerComment}
      import type {FullTextSearchIndex} from '@nowzoo/frieda';
      
      const map: {[key: string]: FullTextSearchIndex} = ${JSON.stringify(map)}
      export default map;
    `;
};

export const getTypesDSourceCode = (
  schema: ParsedSchema,
  bannerComment: string
): string => {
  const typeDeclarations = schema.models
    .map((m) => {
      return [
        m.modelType,
        m.selectAllType,
        m.primaryKeyType,
        m.createType,
        m.updateType,
        m.findUniqueType,
        m.dbType
      ]
        .map((d) => d.declaration)
        .join(`\n`);
    })
    .join('\n\n');

  return `
      ${bannerComment}
      import type {ModelDb} from '@nowzoo/frieda';

      ${typeDeclarations}
      
    `;
};

export const getSchemaSourceCode = (
  schema: ParsedSchema,
  bannerComment: string
): string => {
  const cast: SchemaCastMap = {};
  schema.models.forEach((m) => {
    m.fields.forEach((f) => {
      const key = [m.tableName, f.columnName].join('.');
      cast[key] = f.castType;
    });
  });
  const def: SchemaDefinition = {
    databaseName: schema.databaseName,
    cast,
    models: schema.models.map((m) => {
      const md: ModelDefinition = {
        modelName: m.modelName,
        tableName: m.tableName,
        fields: m.fields.map((f) => {
          const fd: FieldDefinition = {
            fieldName: f.fieldName,
            columnName: f.columnName,
            castType: f.castType,
            hasDefault: f.hasDefault,
            isAutoIncrement: f.isAutoIncrement,
            isPrimaryKey: f.isPrimaryKey,
            mysqlBaseType: f.mysqlBaseType
          };
          return fd;
        })
      };
      return md;
    })
  };

  return `
      ${bannerComment}
      import type {SchemaDefinition} from '@nowzoo/frieda';
      
      const schema: SchemaDefinition = ${JSON.stringify(def)}

      export default schema;
    `;
};
