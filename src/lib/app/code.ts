import type { Schema } from './schema.js';
import prettier from 'prettier';
import { blockComment, getPrettierOptions } from './utils.js';
import { TS_COMPILER_OPTIONS } from './constants.js';
import { tsquery } from '@phenomnomnominal/tsquery';
import { Project } from 'ts-morph';
import type ts from 'typescript';
import { basename, join, extname } from 'node:path';
import {
  type GeneratedFile,
  type LineNumbers,
  type PathResult,
  TypescriptFileName,
  type TypescriptSourceCode
} from './types.js';
import type { FileSystem } from './file-system.js';
import type { Options } from './options.js';

export class Code {
  static async create(
    schema: Schema,
    fs: FileSystem,
    options: Options
  ): Promise<Code> {
    const code = new Code(schema, fs, options);
    await code.initialize();
    return code;
  }

  #files: GeneratedFile[] = [];
  #typesDLineNumbers: LineNumbers = {};

  private constructor(
    public readonly schema: Schema,
    public readonly fs: FileSystem,
    public readonly options: Options
  ) {}

  get files(): GeneratedFile[] {
    return this.#files;
  }

  get typesDLineNumbers(): LineNumbers {
    return this.#typesDLineNumbers;
  }

  async initialize() {
    const outDir = this.options.outputDirectory;
    const prettierOptions = await getPrettierOptions(outDir);
    const src = this.getTypescriptSourceCode();
    const tsFiles: GeneratedFile[] = Object.keys(src).map((k) => {
      const relPath = join(outDir, k);
      return {
        ...this.fs.getPathResult(relPath),
        contents: prettier.format(src[k as TypescriptFileName], {
          ...prettierOptions,
          filepath: relPath
        })
      };
    });
    const typesDFile = tsFiles.find(
      (f) => f.basename === TypescriptFileName.typesD
    ) as GeneratedFile;

    if (this.options.compileJs) {
      const project = new Project({
        compilerOptions: TS_COMPILER_OPTIONS
      });
      tsFiles.forEach((f) => {
        project.createSourceFile(f.relativePath, f.contents, {
          overwrite: true
        });
      });
      const jsFiles: (PathResult & { contents: string })[] = project
        .emitToMemory()
        .getFiles()
        .map((f) => {
          const fname = basename(f.filePath);
          const relPath = join(outDir, fname);
          const contents = ['.js', '.ts'].includes(extname(fname))
            ? prettier.format(f.text, { ...prettierOptions, filepath: relPath })
            : f.text;
          return { ...this.fs.getPathResult(relPath), contents };
        });
      this.#files = [...jsFiles, typesDFile];
    } else {
      this.#files = [...tsFiles];
    }
    const ast = tsquery.ast(typesDFile.contents);
    const nodes: ts.TypeAliasDeclaration[] = tsquery(
      ast,
      'TypeAliasDeclaration'
    );
    nodes.forEach((node) => {
      const name = node.name;
      this.#typesDLineNumbers[name.getText()] =
        ast.getLineAndCharacterOfPosition(node.getStart()).line + 1;
    });
  }

  get bannerComment(): string {
    return `
        /**
         * Generated by Frieda on ${new Date().toUTCString()}
         * Run \`frieda g\` to re-generate.
         */
      `;
  }

  getTypescriptSourceCode(): TypescriptSourceCode {
    return {
      'database.ts': this.getDatabaseSourceCode(),
      'schema.ts': this.getSchemaSourceCode(),
      'search-indexes.ts': this.getSearchIndexesSourceCode(),
      'types.d.ts': this.getTypesDSourceCode()
    };
  }

  getSearchIndexesSourceCode(): string {
    
    const map = JSON.stringify(this.schema.fullTextSearchIndexes);
    return `
        ${this.bannerComment}
        import type {FullTextSearchIndex} from '@nowzoo/frieda';
        
        const map: {[key: string]: FullTextSearchIndex} = ${map}
        export default map;
      `;
  }

  getSchemaSourceCode(): string {
    const schema = JSON.stringify(this.schema);
    return `
      ${this.bannerComment}
      import type {SchemaDefinition} from '@nowzoo/frieda';
      
      const schema: SchemaDefinition = ${schema}

      export default schema;
    `;
  }

  getDatabaseSourceCode(): string {
    return `
      ${this.bannerComment}
      import type { Transaction, Connection } from '@planetscale/database';
      import { BaseDb, ModelDb, type DbLoggingOptions, type Schema } from '@nowzoo/frieda';
      import schema from './schema.js';
      import type {
        ${this.schema.models.map((m) => m.dbTypeName).join(',')}
      } from './types.js';
      export abstract class ModelsDb extends BaseDb {
        private models: Partial<{
          ${this.schema.models
            .map((m) => {
              return `${m.appDbKey}: ${m.dbTypeName}`;
            })
            .join('\n')}
        }>;

        constructor(
          conn: Connection | Transaction,
          schema: Schema,
          loggingOptions: DbLoggingOptions = {}
        ) {
          super(conn, schema, loggingOptions);
          this.models = {};
        }

        ${this.schema.models
          .map((m) => {
            return `
              get ${m.appDbKey}(): ${m.dbTypeName} {
                if (! this.models.${m.appDbKey}) {
                  this.models.${m.appDbKey} = new ModelDb('${m.modelName}', this.connOrTx, schema, this.loggingOptions)
                }
                return this.models.${m.appDbKey} 
              }
            `;
          })
          .join('\n')}
      }

      export class TxDb extends ModelsDb {
        constructor(
          transaction: Transaction,
          loggingOptions: DbLoggingOptions = {}
        ) {
          super(transaction, schema, loggingOptions)
        }
      }

      export class AppDb extends ModelsDb {
        #conn: Connection;
        constructor(
          connection: Connection,
          loggingOptions: DbLoggingOptions = {}
        ) {
          super(connection, schema, loggingOptions);
          this.#conn = connection;
        }
        async transaction<T>(txFn: (txDb: TxDb) => Promise<T>) {
          const result = await this.#conn.transaction(async (tx) => {
            const txDb = new TxDb(tx, this.loggingOptions);
            return await txFn(txDb);
          });
          return result;
        }
      }
    `;
  }

  getTypesDSourceCode(): string {
    const typeDeclarations = this.schema.models
      .map((m) => {
        const invisibleFields = m.fields.filter((f) => f.isInvisible);
        const generatedFields = m.fields.filter((f) => f.isGeneratedAlways);
        const baseModelComment = [
          `The base type for the ${m.modelName} model.`
        ];
        if (invisibleFields.length > 0) {
          baseModelComment.push(
            'Optional fields (`undefined` if the model is queried with `SELECT *`):',
            ...invisibleFields.map(
              (f) => `- \`${f.fieldName}\` (column is \`INVISIBLE\`)`
            )
          );
        }

        const selectAllComment = [
          `The representation of the \`${m.modelName}\` model when fetched using \`SELECT *\`,`,
          `omitting fields where the underlying column is \`INVISIBLE\`.`
        ];
        if (invisibleFields.length > 0) {
          selectAllComment.push(
            'Omitted fields:',
            ...invisibleFields.map(
              (f) => `- \`${f.fieldName}\` (column is \`INVISIBLE\`)`
            )
          );
        }

        const primaryKeyComment = [
          `The primary key type for ${m.modelName}.`,
          `This type is used to update and delete models, and is the return type`,
          `when you create a ${m.modelName} model.`
        ];

        const optionalInCreate = m.fields.filter(
          (f) => f.isAutoIncrement || f.hasDefault
        );
        const createComment = [
          `Data passed to create a new \`${m.modelName}\` model.`
        ];
        if (optionalInCreate.length > 0) {
          createComment.push(
            'Optional fields:',
            ...optionalInCreate.map((f) => {
              if (f.isAutoIncrement) {
                return `- \`${f.fieldName}\` (column is \`auto_increment\`)`;
              }
              return `- \`${f.fieldName}\` (column has a default value)`;
            })
          );
        }
        if (generatedFields.length > 0) {
          createComment.push(
            'Omitted fields:',
            ...generatedFields.map(
              (f) => `- \`${f.fieldName}\` (column is \`GENERATED\`)`
            )
          );
        }
        const omittedInUpdatePrimaryKeys = m.fields.filter(
          (f) => f.isPrimaryKey
        );
        const updateComment = [
          `Data passed to update an existing \`${m.modelName}\` model.`
        ];
        if (
          omittedInUpdatePrimaryKeys.length > 0 ||
          generatedFields.length > 0
        ) {
          updateComment.push(
            'Omitted fields:',
            ...omittedInUpdatePrimaryKeys.map(
              (f) => `- \`${f.fieldName}\` (column is a primary key)`
            ),
            ...generatedFields.map(
              (f) => `- \`${f.fieldName}\` (column is \`GENERATED\`)`
            )
          );
        }

        const findUniqueComment = [
          `Type representing how to uniquely select a \`${m.modelName}\` model`,
          `including the \`${m.primaryKeyTypeName}\` primary key type`,
          `and any other unique indexes found in the table's schema.`
        ];
        const dbComment = [
          `The \`ModelDb\` type for the ${m.modelName} model. `
        ];

        return `
      /** ${m.modelName} types */

      ${blockComment(baseModelComment)}
      ${m.modelTypeDeclaration}

      ${blockComment(selectAllComment)}
      ${m.selectAllTypeDeclaration}

      ${blockComment(primaryKeyComment)}
      ${m.primaryKeyTypeDeclaration}

      ${blockComment(createComment)}
      ${m.createTypeDeclaration}

      ${blockComment(updateComment)}
      ${m.updateTypeDeclaration}

      ${blockComment(findUniqueComment)}
      ${m.findUniqueTypeDeclaration}

      ${blockComment(dbComment)}
      ${m.dbTypeDeclaration}
      
      `;
      })
      .join(`\n\n`);
    return `
      ${this.bannerComment}
      import type {ModelDb} from '@nowzoo/frieda';

      ${typeDeclarations}
    `;
  }
}
