import type { Schema } from './schema.js';
import prettier from 'prettier';
import { blockComment, getFileLink, getPrettierOptions, squishWords } from './utils.js';
import { TS_COMPILER_OPTIONS } from './constants.js';
import { tsquery } from '@phenomnomnominal/tsquery';
import { Project } from 'ts-morph';
import type ts from 'typescript';
import { basename, join, extname } from 'node:path';
import {
  type GeneratedFile,
  type LineNumbers,
  type PathResult,
  TypescriptFileName,
  type TypescriptSourceCode
} from './types.js';
import type { FileSystem } from './file-system.js';
import type { Options } from './options.js';
import stripAnsi from 'strip-ansi';

export class Code {
  static async create(
    schema: Schema,
    fs: FileSystem,
    options: Options
  ): Promise<Code> {
    const code = new Code(schema, fs, options);
    await code.initialize();
    return code;
  }

  #files: GeneratedFile[] = [];
  #typesDLineNumbers: LineNumbers = {};

  #typesDFile: GeneratedFile|undefined

  private constructor(
    public readonly schema: Schema,
    public readonly fs: FileSystem,
    public readonly options: Options
  ) {}

  get files(): GeneratedFile[] {
    return this.#files;
  }

  get typesDLineNumbers(): LineNumbers {
    return this.#typesDLineNumbers;
  }

  get typesDFile(): GeneratedFile {
    if (! this.#typesDFile) {
      throw new Error('Code not yet generated.')
    }
    return this.#typesDFile
  }

  async initialize() {
    const outDir = this.options.outputDirectory;
    const prettierOptions = await getPrettierOptions(outDir);
    const src = this.getTypescriptSourceCode();
    const tsFiles: GeneratedFile[] = Object.keys(src).map((k) => {
      const relPath = join(outDir, k);
      return {
        ...this.fs.getPathResult(relPath),
        contents: prettier.format(src[k as TypescriptFileName], {
          ...prettierOptions,
          filepath: relPath
        })
      };
    });
    this.#typesDFile = tsFiles.find(
      (f) => f.basename === TypescriptFileName.typesD
    ) as GeneratedFile;

    if (this.options.compileJs) {
      const project = new Project({
        compilerOptions: TS_COMPILER_OPTIONS
      });
      tsFiles.forEach((f) => {
        project.createSourceFile(f.relativePath, f.contents, {
          overwrite: true
        });
      });
      const jsFiles: (PathResult & { contents: string })[] = project
        .emitToMemory()
        .getFiles()
        .map((f) => {
          const fname = basename(f.filePath);
          const relPath = join(outDir, fname);
          const contents = ['.js', '.ts'].includes(extname(fname))
            ? prettier.format(f.text, { ...prettierOptions, filepath: relPath })
            : f.text;
          return { ...this.fs.getPathResult(relPath), contents };
        });
      this.#files = [...jsFiles, this.#typesDFile];
    } else {
      this.#files = [...tsFiles];
    }
    const ast = tsquery.ast(this.#typesDFile.contents);
    const nodes: ts.TypeAliasDeclaration[] = tsquery(
      ast,
      'TypeAliasDeclaration'
    );
    nodes.forEach((node) => {
      const name = node.name;
      this.#typesDLineNumbers[name.getText()] =
        ast.getLineAndCharacterOfPosition(node.getStart()).line + 1;
    });
    await Promise.all(this.#files.map(f => this.fs.saveFile(f.relativePath, f.contents)))
  }

  getTypesDFileLink(typeName: string): string {
    const line = this.typesDLineNumbers[typeName];
    return getFileLink(this.typesDFile.relativePath, line)
  }

  get bannerComment(): string {
    return `
        /**
         * Generated by Frieda on ${new Date().toUTCString()}
         * Run \`frieda g\` to re-generate.
         */
      `;
  }

  getTypescriptSourceCode(): TypescriptSourceCode {
    return {
      'database.ts': this.getDatabaseSourceCode(),
      'schema.ts': this.getSchemaSourceCode(),
      'search-indexes.ts': this.getSearchIndexesSourceCode(),
      'types.d.ts': this.getTypesDSourceCode()
    };
  }

  getSearchIndexesSourceCode(): string {
    const map = JSON.stringify(this.schema.fullTextSearchIndexes);
    return `
        ${this.bannerComment}
        import type {FullTextSearchIndex} from '@nowzoo/frieda';
        
        const map: {[key: string]: FullTextSearchIndex} = ${map}
        export default map;
      `;
  }

  getSchemaSourceCode(): string {
    const schema = JSON.stringify(this.schema);
    return `
      ${this.bannerComment}
      import type {SchemaDefinition} from '@nowzoo/frieda';
      
      const schema: SchemaDefinition = ${schema}

      export default schema;
    `;
  }

  getDatabaseSourceCode(): string {
    return `
      ${this.bannerComment}
      import type { Transaction, Connection } from '@planetscale/database';
      import { BaseDb, ModelDb, type DbLoggingOptions, type Schema } from '@nowzoo/frieda';
      import schema from './schema.js';
      import type {
        ${this.schema.models.map((m) => m.dbTypeName).join(',')}
      } from './types.js';
      export abstract class ModelsDb extends BaseDb {
        private models: Partial<{
          ${this.schema.models
            .map((m) => {
              return `${m.appDbKey}: ${m.dbTypeName}`;
            })
            .join('\n')}
        }>;

        constructor(
          conn: Connection | Transaction,
          schema: Schema,
          loggingOptions: DbLoggingOptions = {}
        ) {
          super(conn, schema, loggingOptions);
          this.models = {};
        }

        ${this.schema.models
          .map((m) => {
            return `
              get ${m.appDbKey}(): ${m.dbTypeName} {
                if (! this.models.${m.appDbKey}) {
                  this.models.${m.appDbKey} = new ModelDb('${m.modelName}', this.connOrTx, schema, this.loggingOptions)
                }
                return this.models.${m.appDbKey} 
              }
            `;
          })
          .join('\n')}
      }

      export class TxDb extends ModelsDb {
        constructor(
          transaction: Transaction,
          loggingOptions: DbLoggingOptions = {}
        ) {
          super(transaction, schema, loggingOptions)
        }
      }

      export class AppDb extends ModelsDb {
        #conn: Connection;
        constructor(
          connection: Connection,
          loggingOptions: DbLoggingOptions = {}
        ) {
          super(connection, schema, loggingOptions);
          this.#conn = connection;
        }
        async transaction<T>(txFn: (txDb: TxDb) => Promise<T>) {
          const result = await this.#conn.transaction(async (tx) => {
            const txDb = new TxDb(tx, this.loggingOptions);
            return await txFn(txDb);
          });
          return result;
        }
      }
    `;
  }

  getTypesDSourceCode(): string {
    const typeDeclarations = this.schema.models
      .map((m) => {
        const modelTypeDeclaration = m.modelTypeDeclaration;
        const baseModelComment = [
          ...squishWords(stripAnsi(modelTypeDeclaration.description), 70).split(
            '\n'
          )
        ];
        if (Object.values(modelTypeDeclaration.notes).length > 0) {
          baseModelComment.push(
            ...Object.values(modelTypeDeclaration.notes).map(
              (note) => squishWords(squishWords(`- ${stripAnsi(note)}`.trim()).split('\n').join(' ')).split('\n').join(' ')
            )
          );
        }

        const selectAllTypeDeclaration = m.selectAllTypeDeclaration;

        const selectAllComment = [
          ...squishWords(
            stripAnsi(selectAllTypeDeclaration.description),
            70
          ).split('\n')
        ];
        if (Object.values(selectAllTypeDeclaration.notes).length > 0) {
          selectAllComment.push(
            ...Object.values(selectAllTypeDeclaration.notes).map(
              (note) => squishWords(squishWords(`- ${stripAnsi(note)}`.trim()).split('\n').join(' ')).split('\n').join(' ')
            )
          );
        }

        const primaryKeyTypeDeclaration = m.primaryKeyTypeDeclaration;
        const primaryKeyComment = [
          ...squishWords(
            stripAnsi(primaryKeyTypeDeclaration.description),
            70
          ).split('\n')
        ];
        if (Object.values(primaryKeyTypeDeclaration.notes).length > 0) {
          primaryKeyComment.push(
            ...Object.values(primaryKeyTypeDeclaration.notes).map(
              (note) => squishWords(squishWords(`- ${stripAnsi(note)}`.trim()).split('\n').join(' ')).split('\n').join(' ')
            )
          );
        }

        const createTypeDeclaration = m.createTypeDeclaration;
        const createComment = [
          ...squishWords(
            stripAnsi(createTypeDeclaration.description),
            70
          ).split('\n')
        ];
        if (Object.values(createTypeDeclaration.notes).length > 0) {
          createComment.push(
            ...Object.values(createTypeDeclaration.notes).map(
              (note) => squishWords(squishWords(`- ${stripAnsi(note)}`.trim()).split('\n').join(' ')).split('\n').join(' ')
            )
          );
        }

        const updateTypeDeclaration = m.updateTypeDeclaration;
        const updateComment = [
          ...squishWords(
            stripAnsi(updateTypeDeclaration.description),
            70
          ).split('\n')
        ];
        if (Object.values(updateTypeDeclaration.notes).length > 0) {
          updateComment.push(
            ...Object.values(updateTypeDeclaration.notes).map(
              (note) => squishWords(squishWords(`- ${stripAnsi(note)}`.trim()).split('\n').join(' ')).split('\n').join(' ')
            )
          );
        }
        const findUniqueTypeDeclaration = m.findUniqueTypeDeclaration;
        const findUniqueComment = [
          ...squishWords(
            stripAnsi(findUniqueTypeDeclaration.description),
            70
          ).split('\n')
        ];
        if (findUniqueTypeDeclaration.notes.length > 0) {
          findUniqueComment.push(
            'Unique indexes:',
            ...findUniqueTypeDeclaration.notes.map(
              (note) => squishWords(squishWords(`- ${stripAnsi(note)}`.trim()).split('\n').join(' ')).split('\n').join(' ')
            )
          );
        }

        const dbTypeDeclaration = m.dbTypeDeclaration;
        const dbComment = [
          ...squishWords(
            stripAnsi(findUniqueTypeDeclaration.description),
            70
          ).split('\n')
        ];

        return `
      /** ${m.modelName} types */

      ${blockComment(baseModelComment)}
      ${modelTypeDeclaration.declaration}

      ${blockComment(selectAllComment)}
      ${selectAllTypeDeclaration.declaration}

      ${blockComment(primaryKeyComment)}
      ${primaryKeyTypeDeclaration.declaration}

      ${blockComment(createComment)}
      ${createTypeDeclaration.declaration}

      ${blockComment(updateComment)}
      ${updateTypeDeclaration.declaration}

      ${blockComment(findUniqueComment)}
      ${findUniqueTypeDeclaration.declaration}

      ${blockComment(dbComment)}
      ${dbTypeDeclaration.declaration}
      
      `;
      })
      .join(`\n\n`);
    return `
      ${this.bannerComment}
      import type {ModelDb} from '@nowzoo/frieda';

      ${typeDeclarations}
    `;
  }
}
