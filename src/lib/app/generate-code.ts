import type {
  FieldDefinition,
  FullTextSearchIndex,
  ModelDefinition,
  SchemaCastMap,
  SchemaDefinition
} from '../api/types.js';
import type { Options } from './options.js';
import type { ParsedField, ParsedModel, ParsedSchema } from './types.js';
import { basename, join, extname } from 'node:path';
import { Project } from 'ts-morph';
import fs from 'fs-extra';
import { squishWords } from './utils.js';
import prettier from 'prettier';
import { TS_COMPILER_OPTIONS } from './constants.js';
import ora from 'ora';
export const generateCode = async (
  options: Options,
  schema: ParsedSchema
): Promise<string[]> => {
  const spinner = ora('Generating code...').start();
  let filesToWrite: { filePath: string; code: string }[] = [];

  const bannerComment = `
  /**
   * Generated by frieda on ${new Date().toUTCString()}
   */
  `;
  const modelsDTsCode: { filePath: string; code: string } = {
    filePath: join(options.cwd, options.outputDirectory, 'models.d.ts'),
    code: getModelsDSourceCode(schema, bannerComment)
  };
  modelsDTsCode.code = prettier.format(modelsDTsCode.code, {
    ...options.prettierOptions,
    filepath: modelsDTsCode.filePath
  });

  const otherTsTfiles: { filePath: string; code: string }[] = [
    {
      filePath: join(options.cwd, options.outputDirectory, 'schema.ts'),
      code: getSchemaSourceCode(schema, bannerComment)
    },
    {
      filePath: join(options.cwd, options.outputDirectory, 'search-indexes.ts'),
      code: getSearchIndexesSourceCode(schema, bannerComment)
    },
    {
      filePath: join(options.cwd, options.outputDirectory, 'database.ts'),
      code: getDatabaseSourceCode(schema, bannerComment)
    }
  ].map((o) => {
    return {
      code: prettier.format(o.code, {
        ...options.prettierOptions,
        filepath: o.filePath
      }),
      filePath: o.filePath
    };
  });
  if (options.compileJs) {
    const project = new Project({
      compilerOptions: TS_COMPILER_OPTIONS
    });
    [...otherTsTfiles, modelsDTsCode].forEach((f) => {
      project.createSourceFile(f.filePath, f.code, { overwrite: true });
    });
    const jsFiles: { filePath: string; code: string }[] = project
      .emitToMemory()
      .getFiles()
      .filter((f) =>
        f.filePath.startsWith(join(options.cwd, options.outputDirectory))
      )
      .map((f) => {
        const b = basename(f.filePath);
        const contents = ['.js', '.ts'].includes(extname(b))
          ? prettier.format(f.text, {
              ...options.prettierOptions,
              filepath: f.filePath
            })
          : f.text;
        return {
          filePath: f.filePath,
          code: contents
        };
      });
    jsFiles.push(modelsDTsCode);
    filesToWrite = [...jsFiles];
  } else {
    filesToWrite = [...otherTsTfiles, modelsDTsCode];
  }
  await fs.ensureDir(join(options.cwd, options.outputDirectory));
  await fs.emptyDir(join(options.cwd, options.outputDirectory));
  await Promise.all(filesToWrite.map((f) => fs.writeFile(f.filePath, f.code)));
  spinner.succeed('Code generated.');
  return filesToWrite.map((f) => f.filePath);
};

export const getModelsDSourceCode = (
  schema: ParsedSchema,
  bannerComment: string
): string => {
  const modelTypeDeclarations = schema.models
    .map((m) => {
      return [
        getModelTypeDeclaration(m),
        getSelectAllTypeDeclaration(m),
        getPrimaryKeyTypeDeclaration(m),
        getCreateTypeDeclaration(m),
        getUpdateTypeDeclaration(m),
        getFindUniqueTypeDeclaration(m),
        getDbTypeDeclaration(m)
      ].join('\n');
    })
    .join('\n\n');

  // console.log(viewTypeDeclarations);
  return `
  ${bannerComment}
  import type {ModelDb, ViewDb} from '@nowzoo/frieda';

  ${modelTypeDeclarations}
  `;
};

export const getModelTypeDeclaration = (model: ParsedModel): string => {
  const props: string[] = [];
  const notes: string[] = [];
  for (const f of model.fields) {
    if (f.isInvisible) {
      notes.push(`- ${f.fieldName} is **optional** (column is \`INVISIBLE\`)`);
    }
    const orNull = f.isNullable ? '|null' : '';
    const opt = f.isInvisible ? '?' : '';
    props.push(`${f.fieldName}${opt}:${f.javascriptType}${orNull}`);
  }
  const desc = squishWords(
    `
    The base model type for \`${model.modelName}\`.
    Fields where the underlying column is \`INVISIBLE\` are **optional**
    in this type, since they are omitted when the model is queried with \`SELECT *\`.
    `,
    60
  )
    .split(`\n`)
    .map((s) => s.trim());
  const commentLines = [...desc, ...notes];
  const comment = [`/**`, ...commentLines.map((s) => ` * ${s}`), ` */`].join(
    '\n'
  );
  const declaration = `export type ${model.modelName} = {
    ${props.join(';\n')}
  }`;
  return [comment, declaration].join('\n');
};

export const getSelectAllTypeDeclaration = (model: ParsedModel): string => {
  const props: string[] = [];
  const notes: string[] = [];
  for (const f of model.fields) {
    if (f.isInvisible) {
      notes.push(`- ${f.fieldName} is **omitted** (column is \`INVISIBLE\`)`);
    } else {
      const orNull = f.isNullable ? '|null' : '';
      const opt = f.isInvisible ? '?' : '';
      props.push(`${f.fieldName}${opt}:${f.javascriptType}${orNull}`);
    }
  }
  const desc = squishWords(
    `
    Represents the data returned when the \`${model.modelName} model is
    queried with \`SELECT *\`. Fields where the underlying column 
    is \`INVISIBLE\` are omitted from this type.
    `,
    60
  )
    .split(`\n`)
    .map((s) => s.trim());
  const commentLines = [...desc, ...notes];

  const comment = [`/**`, ...commentLines.map((s) => ` * ${s}`), ` */`].join(
    '\n'
  );
  const declaration = `export type ${model.selectAllTypeName} = {
    ${props.join(';\n')}
  }`;
  return [comment, declaration].join('\n');
};

export const getPrimaryKeyTypeDeclaration = (model: ParsedModel): string => {
  const props: string[] = [];
  const notes: string[] = [];
  for (const f of model.fields) {
    if (f.isPrimaryKey) {
      notes.push(`- ${f.fieldName} is a primary key`);
      props.push(`${f.fieldName}:${f.javascriptType}`);
    }
  }
  const desc = squishWords(
    `
      The primary key type for the \`${model.modelName} model.
      This is returned when you create a model and is used to select models by primary key.
    `,
    60
  )
    .split(`\n`)
    .map((s) => s.trim());
  const commentLines = [...desc, ...notes];
  const comment = [`/**`, ...commentLines.map((s) => ` * ${s}`), ` */`].join(
    '\n'
  );
  const declaration = `export type ${model.primaryKeyTypeName} = {
    ${props.join(';\n')}
  }`;
  return [comment, declaration].join('\n');
};

export const getCreateTypeDeclaration = (model: ParsedModel): string => {
  const props: string[] = [];
  const notes: string[] = [];
  for (const f of model.fields) {
    if (f.isGeneratedAlways) {
      notes.push(`- ${f.fieldName} is **omitted** (column is \`GENERATED\`)`);
    } else {
      if (f.isAutoIncrement) {
        notes.push(
          `${f.fieldName} is **optional** (column is \`auto_increment\`)`
        );
      } else if (f.hasDefault) {
        notes.push(
          `${f.fieldName} is **optional** (column has a default value)`
        );
      }
      const opt = f.hasDefault || f.isAutoIncrement ? '?' : '';
      const orNull = f.isNullable ? '|null' : '';
      props.push(`${f.fieldName}${opt}:${f.javascriptType}${orNull}`);
    }
  }
  const desc = squishWords(
    `
    Data passed to create a new \`${model.modelName}\` model. Fields where
    the underlying column is \`GENERATED\` are omitted. Fields where the underlying column is \`auto_increment\` or has a
    default value are optional.
     
    `,
    60
  )
    .split(`\n`)
    .map((s) => s.trim());
  const commentLines = [...desc, ...notes];
  const comment = [`/**`, ...commentLines.map((s) => ` * ${s}`), ` */`].join(
    '\n'
  );
  const declaration = `export type ${model.createTypeName} = {
    ${props.join(';\n')}
  }`;
  return [comment, declaration].join('\n');
};

export const getUpdateTypeDeclaration = (model: ParsedModel): string => {
  const props: string[] = [];
  const notes: string[] = [];
  for (const f of model.fields) {
    if (f.isGeneratedAlways) {
      notes.push(`- ${f.fieldName} is **omitted** (column is \`GENERATED\`)`);
    } else if (f.isPrimaryKey) {
      notes.push(`- ${f.fieldName} is **omitted** (column is a primary key)`);
    } else {
      const orNull = f.isNullable ? '|null' : '';
      props.push(`${f.fieldName}?:${f.javascriptType}${orNull}`);
    }
  }

  const desc = squishWords(
    `
      Data passed to update an existing \`${model.modelName}\` model. Fields where
      the underlying column is \`GENERATED\` or is a primary key are omitted.
      All other fields are optional
     
    `,
    60
  )
    .split(`\n`)
    .map((s) => s.trim());

  const commentLines = [...desc, ...notes];
  const comment = [`/**`, ...commentLines.map((s) => ` * ${s}`), ` */`].join(
    '\n'
  );
  const declaration = `export type ${model.updateTypeName} = {
    ${props.join(';\n')}
  }`;
  return [comment, declaration].join('\n');
};

export const getFindUniqueTypeDeclaration = (model: ParsedModel): string => {
  const uniqueTypes: string[] = [model.primaryKeyTypeName];
  const notes: string[] = [];
  for (const index of model.indexes.filter(
    (i) => i.isUnique && i.indexName !== 'PRIMARY'
  )) {
    const propSigs = index.indexedColumns.map((c) => {
      const f = model.fields.find((f) => f.columnName === c) as ParsedField;
      return `${f.fieldName}:${f.javascriptType}`;
    });
    uniqueTypes.push(`{${propSigs.join('\n')}}`);
    notes.push(`Unique index \`${index.indexName}\``);
  }
  const desc = squishWords(
    `
      Type representing how to uniquely select a \`${model.modelName}\` model. 
      This includes the \`${model.primaryKeyTypeName}\` primary key type plus 
      types derived from the table's other unique indexes.
    `,
    60
  )
    .split(`\n`)
    .map((s) => s.trim());
  const commentLines = [...desc, ...notes];
  const comment = [`/**`, ...commentLines.map((s) => ` * ${s}`), ` */`].join(
    '\n'
  );

  const declaration = `export type ${
    model.findUniqueTypeName
  }=${uniqueTypes.join('|')}`;
  return [comment, declaration].join('\n');
};

export const getDbTypeDeclaration = (model: ParsedModel): string => {
  const desc = squishWords(
    `
      Database type for the \`${model.modelName}\` model. 
    `,
    60
  )
    .split(`\n`)
    .map((s) => s.trim());
  const commentLines = [...desc];
  const comment = [`/**`, ...commentLines.map((s) => ` * ${s}`), ` */`].join(
    '\n'
  );
  const els = [
    model.modelName,
    model.selectAllTypeName,
    model.primaryKeyTypeName,
    model.createTypeName,
    model.updateTypeName,
    model.findUniqueTypeName
  ];
  const declaration = `export type ${model.dbTypeName}=ModelDb<${els.join(
    ','
  )}>`;
  return [comment, declaration].join('\n');
};

export const getDatabaseSourceCode = (
  schema: ParsedSchema,
  bannerComment: string
): string => {
  const code = `
  ${bannerComment}
  import type { Transaction, Connection } from '@planetscale/database';
  import { BaseDb, ModelDb, ViewDb, type DbLoggingOptions, type SchemaDefinition } from '@nowzoo/frieda';
  import schema from './schema.js';
  import type {
    ${schema.models.map((m) => m.dbTypeName).join(',')}
  } from './models.js';
   
    export abstract class ModelsDb extends BaseDb {
      private models: Partial<{
        ${schema.models
          .map((m) => {
            return `${m.appDbKey}: ${m.dbTypeName}`;
          })
          .join('\n')}
      }>;

      

      constructor(
        conn: Connection | Transaction,
        schema: SchemaDefinition,
        loggingOptions: DbLoggingOptions = {}
      ) {
        super(conn, schema, loggingOptions);
        this.models = {};
      }

      ${schema.models
        .map((m) => {
          return `
            get ${m.appDbKey}(): ${m.dbTypeName} {
              if (! this.models.${m.appDbKey}) {
                this.models.${m.appDbKey} = new ModelDb('${m.modelName}', this.connOrTx, schema, this.loggingOptions)
              }
              return this.models.${m.appDbKey} 
            }
          `;
        })
        .join('\n')}

        
    }

    export class TxDb extends ModelsDb {
      constructor(
        transaction: Transaction,
        loggingOptions: DbLoggingOptions = {}
      ) {
        super(transaction, schema, loggingOptions)
      }
    }

    export class AppDb extends ModelsDb {
      #conn: Connection;
      constructor(
        connection: Connection,
        loggingOptions: DbLoggingOptions = {}
      ) {
        super(connection, schema, loggingOptions);
        this.#conn = connection;
      }
      async transaction<T>(txFn: (txDb: TxDb) => Promise<T>) {
        const result = await this.#conn.transaction(async (tx) => {
          const txDb = new TxDb(tx, this.loggingOptions);
          return await txFn(txDb);
        });
        return result;
      }
    }
  `;
  return code;
};

export const getSearchIndexesSourceCode = (
  schema: ParsedSchema,
  bannerComment: string
): string => {
  const map: { [key: string]: FullTextSearchIndex } = schema.models.reduce(
    (acc, m) => {
      const copy = { ...acc };
      const indexes = m.indexes.filter((i) => i.isFullTextSearch);
      indexes.forEach((i) => {
        const fi: FullTextSearchIndex = {
          indexedFields: i.indexedColumns,
          key: i.indexName,
          tableName: m.tableName
        };
        copy[fi.key] = fi;
      });
      return copy;
    },
    {} as { [key: string]: FullTextSearchIndex }
  );

  return `
        ${bannerComment}
        import type {FullTextSearchIndex} from '@nowzoo/frieda';
        
        const map: {[key: string]: FullTextSearchIndex} = ${JSON.stringify(map)}
        export default map;
    `;
};

export const getSchemaSourceCode = (
  schema: ParsedSchema,
  bannerComment: string
): string => {
  const cast: SchemaCastMap = {};
  schema.models.forEach((m) => {
    m.fields.forEach((f) => {
      const key = [m.tableName, f.columnName].join('.');
      cast[key] = f.castType;
    });
  });
  const def: SchemaDefinition = {
    databaseName: schema.databaseName,
    cast,
    models: schema.models.map((m) => {
      const md: ModelDefinition = {
        modelName: m.modelName,
        tableName: m.tableName,
        fields: m.fields.map((f) => {
          const fd: FieldDefinition = {
            fieldName: f.fieldName,
            columnName: f.columnName,
            castType: f.castType,
            hasDefault: f.hasDefault,
            isAutoIncrement: f.isAutoIncrement,
            isPrimaryKey: f.isPrimaryKey,
            mysqlBaseType: f.mysqlBaseType
          };
          return fd;
        })
      };
      return md;
    })
  };

  return `
    ${bannerComment}
    import type {SchemaDefinition} from '@nowzoo/frieda';
    
    const schema: SchemaDefinition = ${JSON.stringify(def)}

    export default schema;
      
    `;
};
