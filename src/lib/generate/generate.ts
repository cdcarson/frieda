import { compileJavascript } from './compile-javascript.js';
import { removeRecognizedFiles } from './remove-recognized-files.js';
import type { FsPaths } from '$lib/fs/types.js';
import type { FetchedSchema } from '../fetch/types.js';
import type { JavascriptCode, TypescriptCode } from './types.js';
import { getDatabaseTs } from './get-database-ts.js';
import { getSchemaTs } from './get-schema-ts.js';
import { getTypesTs } from './get-types-ts.js';
import { writeFiles } from './write-files.js';
import { getFullTextSearchIndexesTs } from './get-full-text-search-indexes-ts.js';
import { saveFile } from '$lib/fs/save-file.js';
import { join } from 'node:path';
export const generate = async (
  schema: FetchedSchema,
  typeImports: string[],
  outputDirectory: string,
  compileJs: boolean
): Promise<FsPaths[]> => {
  await removeRecognizedFiles(outputDirectory);
  const bannerComment = `
    /**
     * Generated by Frieda on ${new Date().toUTCString()}
     * Run \`frieda g\` to re-generate.
     */
  `;

  const typescript: TypescriptCode = {
    'database.ts': getDatabaseTs(schema, bannerComment),
    'schema.ts': getSchemaTs(schema, bannerComment),
    'types.ts': getTypesTs(schema, typeImports, bannerComment),
    'full-text-search-indexes.ts': getFullTextSearchIndexesTs(
      schema,
      bannerComment
    )
  };

  let out: TypescriptCode | JavascriptCode = typescript;
  const files = await writeFiles(out, outputDirectory);

  if (compileJs) {
    out = compileJavascript(files) as JavascriptCode;
    await removeRecognizedFiles(outputDirectory);
  }

  await saveFile(
    join(outputDirectory, 'schema-debug.json'),
    JSON.stringify(schema, null, 2)
  );

  return await writeFiles(out, outputDirectory);
};
