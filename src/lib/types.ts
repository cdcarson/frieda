import type { KNOWN_MYSQL_TYPES } from './constants';

/**
 * The base type for models
 */
export type Model = Record<string, unknown>;

/**
 * A simplified set of casting rules. We infer this for each schema field from:
 * - the database column type,
 * - optional type annotations in the column definition COMMENT
 * - global settings in .friedarc
 *
 * In addition, this is used to provide one-off cast overrides to db.executeSelect
 * in the case where columns returned from a query do not map to the schema.
 */
export type CastType =
  | 'string'
  | 'bigint'
  | 'int'
  | 'float'
  | 'json'
  | 'date'
  | 'boolean'
  | 'set'
  | 'enum';




export type FieldDefinition<Name extends string> = {
  /**
   * The javascript field name (camelCase'd columnName)
   */
  fieldName: Name;

  /**
   * The actual database column name. Can be any reasonable thing.
   */
  columnName: string;

  /**
   * The full database type.
   */
  columnType: string;

  /**
   * A normalized database type (a type string without any `(<M>)` args or `UNSIGNED` flags.)
   * Used to simplify further inference and to debug.
   */
  knownMySQLType: (typeof KNOWN_MYSQL_TYPES)[number] | null;

  /**
   * How to actually cast the value, received from the database as
   * `string|null`, into javascript, e.g. `parseInt`, `parseFloat`, etc.
   * Note that though this is used to help infer the userland javascript
   * type (see below) there isn't a one-one mapping.
   */
  castType: CastType;

  /**
   * The userland javascript field type, inferred from the cast type, the column type def,
   * column type annotations and global generate settings.
   */
  javascriptType: string;

  /**
   * If true the model update data type will omit the field
   * (we don't wanna update primary keys, ever.)
   */
  isColumnPrimaryKey: boolean;

  /**
   * If true the column is auto incremented, so
   * the model create data type will make it optional
   */
  isColumnAutoIncrement: boolean;

  /**
   * If true the column is VIRTUAL GENERATED or STORED GENERATED, so
   * the model create/updatw data type will omit the field.
   */
  isColumnAlwaysGenerated: boolean;

  /**
   * Whether a column is something like...
   *    `testDefIntExpr` int NOT NULL DEFAULT ((1 + 1))
   *    `createdAt` datetime(3) NOT NULL DEFAULT CURRENT_TIMESTAMP(3)
   *    `updatedAt` datetime(3) NOT NULL DEFAULT CURRENT_TIMESTAMP(3) ON UPDATE CURRENT_TIMESTAMP(3)
   * ...with a default value generated by an expression.
   *
   * If so, column.Extra will contain the string 'DEFAULT_GENERATED'.
   *
   * Net: the field will be optional in the model create type.
   */
  isColumnDefaultGenerated: boolean;

  /**
   * Whether the column has been marked INVISIBLE, i.e.,
   * it won't be selected by a `SELECT *` statement.
   *
   * In this case the model field will be possibly undefined: `foo?: number` or `foo?: number|null`
   * Note this is typed differently from plain null optionality: `foo: number|null`
   *
   * Todo: select(input) may be able to be typed according to input.select, but we don't want to get too fancy
   */
  isColumnInvisible: boolean;

  /**
   * Can the field be null?
   *
   * True if column.Null === 'YES'
   *
   * net: the field is typed as `foo: <type>|null`
   */
  isColumnNullable: boolean;

  /**
   * Whether the model can be uniquely selected by this field.
   *
   * Derived from column.Key === 'UNI'
   */
  isColumnUnique: boolean;
};

export type ModelDefinition<M extends Model, Name extends string> = {
  // The javascript model name (PascalCase'd columnName)
  name: Name;
  tableName: string;
  fields: {
    [N in keyof M & string]: FieldDefinition<N>;
  };
};

/**
 * A row from a `SHOW FULL COLUMNS FROM TableName` query.
 * see https://dev.mysql.com/doc/refman/8.0/en/show-columns.html
 */
export type DatabaseTableColumnInfo = {
  /**
   * The name of the column.
   * We use this to get the javascript field name.
   */
  Field: string;

  /**
   * The  MySQL type definition.
   * We use this to help derive the javascript field type.
   * It is not enough,
   */
  Type: string;

  /**
   * Whether the javascript type can be `null`:
   * `'NO'`: `foo: <jstype>`
   * vs
   * 'YES': `foo: <jstype>|null`
   */
  Null: 'YES' | 'NO';

  /**
   * We ignore this.
   */
  Collation: string | null;

  /**
   * There's a whole lot going on with `Key`, but all
   * we're interested in is whether (1) the field is a
   * primary key or, failing that, (2) whether it is
   * uniquely indexed (for example, `User.email` where
   * no two `User`s can have the same email.)
   *
   * If `Key` === 'PRI` the field is a primary key.
   * If `Key` === 'UNI` the field is uniquely indexed.
   *
   * If the field is a primary key, it will be included in
   * primary key map returned by create.
   *
   * If the field is unique, then we infer that you can
   * select unique by it.
   *
   * @todo this documentation needs work.
   */
  Key: string;

  /**
   * We ignore this. All we need to know abot whether a column
   * has a default comes from `Extra` (see below) and `Null`
   */
  Default: string | null;

  // Extra:
  // from the docs...
  // auto_increment for columns that have the AUTO_INCREMENT attribute.
  // on update CURRENT_TIMESTAMP for TIMESTAMP or DATETIME columns that have the ON UPDATE CURRENT_TIMESTAMP attribute.
  // VIRTUAL GENERATED or STORED GENERATED for generated columns.
  // DEFAULT_GENERATED for columns that have an expression default value.
  // but also...
  // INVISIBLE if the column is so (there is no "VISIBLE" afaict)

  /**
   * Used to infer whether:
   * - the column is auto_increment
   * - the column is "always generated" (so omitted from the model's create and update data types)
   * - whether the column is DEFAULT_GENERATED (e.g. timestamps)
   * - whether the column is invisible
   */
  Extra: string;

  /**
   * Used to store type annotations
   */
  Comment: string;

  /**
   * We ignore this.
   */
  Privileges: string;
};
/**
 * A row from `SHOW INDEXES FROM FROM TableName`
 */
export type DatabaseTableIndexInfo = {
  Table: string;
  Non_unique: number;
  Key_name: string;
  Seq_in_index: number;
  Column_name: string | null;
  Collation: string | null;
  Cardinality: string;
  Sub_part: string | null;
  Packed: string | null;
  Null: string;
  Index_type: string;
  Comment: string;
  Index_comment: string;
  Visible: string;
  Expression: string | null;
};
export type DatabaseTableInfo = {
  name: string;
  columns: DatabaseTableColumnInfo[];
  indexes: DatabaseTableIndexInfo[];
  tableCreateStatement: string;
};

export type DatabaseSchema = {
  fetched: Date;
  databaseName: string;
  tableNames: string[];
  tables: DatabaseTableInfo[];
};

export type FieldTypeSettings = {
  /**
   * Whether to automatically cast `tinyint(1)` columns to boolean.
   * Default: true
   */
  typeTinyIntOneAsBoolean?: boolean;

  /**
   * Whether to automatically cast `bigint` columns to string.
   * Default: true
   */
  typeBigIntAsString?: boolean;
};
