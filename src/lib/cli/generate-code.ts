import type { ModelDefinition } from '$lib/api/types.js';
import { join, relative, extname, basename } from 'path';
import fs from 'fs-extra';
import { prettify } from '$lib/cli/utils.js';
import type { FullSettings } from './types.js';

const GENERATED_CODE_FILENAMES = {
  types: 'types.ts',
  database: 'database.ts',
  schemaCast: 'schema-cast.ts',
  modelDefinitions: 'model-definitions.ts'
};

const SCHEMA_CAST_CONST_NAME = 'schemaCast';

export const generateCode = async (
  models: ModelDefinition[],
  settings: FullSettings
): Promise<string[]> => {
  const bannerComment = `
    /**
     * Generated by frieda on ${new Date().toUTCString()}
     * Run \`frieda g\` to regenerate.
     */ 
  `;
  return await Promise.all([
    generateModelDefinitionsTs(models, settings, bannerComment),
    generateTypesTs(models, settings, bannerComment),
    generateSchemaCastsTs(models, settings, bannerComment),
    generateDatabaseTs(models, settings, bannerComment)
  ]);
};

const generateModelDefinitionsTs = async (
  models: ModelDefinition[],
  settings: FullSettings,
  bannerComment: string
): Promise<string> => {
  const filePath = join(
    process.cwd(),
    settings.generatedCodeDirectory,
    GENERATED_CODE_FILENAMES.modelDefinitions
  );
  const ts = `
    ${bannerComment}

    import type { ModelDefinition } from '@nowzoo/frieda';

    ${models
      .map((m) => {
        return `export const ${
          m.modelDefinitionConstName
        }: ModelDefinition = ${JSON.stringify(m)}`;
      })
      .join('\n\n')}
  `;
  const prettified = await prettify(ts, filePath);
  await fs.ensureFile(filePath);
  await fs.writeFile(filePath, prettified);
  return relative(process.cwd(), filePath);
};

const generateSchemaCastsTs = async (
  models: ModelDefinition[],
  settings: FullSettings,
  bannerComment: string
) => {
  const filePath = join(
    process.cwd(),
    settings.generatedCodeDirectory,
    GENERATED_CODE_FILENAMES.schemaCast
  );
  const ts = `
    ${bannerComment}
    import type { SchemaCast } from '@nowzoo/frieda';
   
    export const ${SCHEMA_CAST_CONST_NAME} : SchemaCast = {
      ${models
        .flatMap((m) => {
          return m.fields.map(
            (f) => `'${m.tableName}.${f.columnName}': '${f.castType}'`
          );
        })
        .join(',\n')}
    }
  `;

  const prettified = await prettify(ts, filePath);
  await fs.ensureFile(filePath);
  await fs.writeFile(filePath, prettified);
  return relative(process.cwd(), filePath);
};

/**
 * Get the typescript code for <generatedCodeDirectory>/models.d.ts.
 */
const generateTypesTs = async (
  models: ModelDefinition[],
  settings: FullSettings,
  bannerComment: string
): Promise<string> => {
  const filePath = join(
    process.cwd(),
    settings.generatedCodeDirectory,
    GENERATED_CODE_FILENAMES.types
  );
  const types = models
    .map((m) => {
      const modelTypeDecl = `export type ${m.modelName} = {
      ${m.fields
        .map((f) => {
          return `${f.fieldName}${f.isOmittableInModel ? '?' : ''}: ${
            f.javascriptType
          }${f.isNullable ? '|null' : ''};`;
        })
        .join(`\n`)}
    }`;
      const modelPrimaryKeyTypeDecl = `export type ${
        m.modelPrimaryKeyTypeName
      } = {
      ${m.fields
        .filter((f) => f.isPrimaryKey)
        .map((f) => {
          return `${f.fieldName}: ${f.javascriptType};`;
        })
        .join('\n')}
    }`;
      const modelCreateDataTypeDecl = `export type ${
        m.modelCreateDataTypeName
      } = {
      ${m.fields
        .filter((f) => !f.isOmittedFromCreateData)
        .map((f) => {
          return `${f.fieldName}${f.isOptionalInCreateData ? '?' : ''}: ${
            f.javascriptType
          }${f.isNullable ? '|null' : ''};`;
        })
        .join('\n')}
    }`;
      const modelUpdateDataTypeDecl = `export type ${
        m.modelUpdateDataTypeName
      } = {
      ${m.fields
        .filter((f) => !f.isOmittedFromUpdateData)
        .map((f) => {
          return `${f.fieldName}?: ${f.javascriptType}${
            f.isNullable ? '|null' : ''
          };`;
        })
        .join('\n')}
    }`;
      const modelFindUniqueTypeDecl = `export type ${
        m.modelFindUniqueParamsTypeName
      } = ${[
        m.modelPrimaryKeyTypeName,
        ...m.fields
          .filter((f) => f.isUnique)
          .map((f) => `{${f.fieldName}:${f.javascriptType}}`)
      ].join('|')}`;

      const modelRepoTypeDecl = `export type ${m.modelRepoTypeName} = ModelRepo<
      ${m.modelName},
      ${m.modelPrimaryKeyTypeName},
      ${m.modelCreateDataTypeName},
      ${m.modelUpdateDataTypeName},
      ${m.modelFindUniqueParamsTypeName}
    >`;
      return `
    /**
     * Types for the ${m.modelName} model
     */
    ${modelTypeDecl}
    ${modelPrimaryKeyTypeDecl}
    ${modelCreateDataTypeDecl}
    ${modelUpdateDataTypeDecl}
    ${modelFindUniqueTypeDecl}
    ${modelRepoTypeDecl}
   
    `;
    })
    .join('\n\n');

  const ts = `
    ${bannerComment}
    
    import type {ModelRepo} from '@nowzoo/frieda';
    ${(settings.jsonTypeImports || []).join('\n')}

    ${types}
  `;
  const prettified = await prettify(ts, filePath);
  await fs.ensureFile(filePath);
  await fs.writeFile(filePath, prettified);
  return relative(process.cwd(), filePath);
};

const generateDatabaseTs = async (
  models: ModelDefinition[],
  settings: FullSettings,
  bannerComment: string
): Promise<string> => {
  const filePath = join(
    process.cwd(),
    settings.generatedCodeDirectory,
    GENERATED_CODE_FILENAMES.database
  );

  const ts = `
  ${bannerComment}

  import type { Connection, Transaction } from '@planetscale/database';
  import { AbstractDb, ModelRepo, type DbLoggingOptions } from '@nowzoo/frieda';
  import type {
    ${models.map((m) => m.modelRepoTypeName).join(',\n')}
  } from './types'
  import {
    ${models.map((m) => m.modelDefinitionConstName).join(',\n')}
  } from './${basename(
    GENERATED_CODE_FILENAMES.modelDefinitions,
    extname(GENERATED_CODE_FILENAMES.modelDefinitions)
  )}.js'

  import {
    ${SCHEMA_CAST_CONST_NAME}
  } from './${basename(
    GENERATED_CODE_FILENAMES.schemaCast,
    extname(GENERATED_CODE_FILENAMES.schemaCast)
  )}.js'

  export abstract class ReposDb extends AbstractDb {
    
    private repos: Partial<{
      ${models
        .map((m) => {
          return `${m.classRepoName}: ${m.modelRepoTypeName};`;
        })
        .join('\n')}
    }> = {};

    constructor(
      connOrTx: Connection | Transaction,
      loggingOptions: DbLoggingOptions = {}
    ) {
      super(connOrTx, ${SCHEMA_CAST_CONST_NAME}, loggingOptions)
    }

    ${models
      .map((m) => {
        return `get ${m.classRepoName} (): ${m.modelRepoTypeName} {
          if (! this.repos.${m.classRepoName}) {
            this.repos.${m.classRepoName} = new ModelRepo(
              ${m.modelDefinitionConstName}, 
              this.connection, 
              this.schemaCast, 
              this.loggingOptions
            )
          }
          return this.repos.${m.classRepoName};
        }`;
      })
      .join('\n\n')}
  }

  export class TxDb extends ReposDb {
    constructor(
      transaction: Transaction,
      loggingOptions: DbLoggingOptions = {}
    ){
      super(transaction, loggingOptions)
    }
  }
  

  export class AppDb extends ReposDb {
    constructor(private conn: Connection, loggingOptions: DbLoggingOptions = {}) {
      super(conn, loggingOptions);
    }
  
    async transaction<T>(txFn: (txDb: TxDb) => Promise<T>) {
      const result = await this.conn.transaction(async (tx) => {
        const txDb = new TxDb(tx, this.loggingOptions);
        return await txFn(txDb);
      });
      return result;
    }
  }
  `;
  const prettified = await prettify(ts, filePath);
  await fs.ensureFile(filePath);
  await fs.writeFile(filePath, prettified);
  return relative(process.cwd(), filePath);
};
