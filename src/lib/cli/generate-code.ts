import ora from 'ora';
import { prettifyAndSaveFile } from './fs/prettify-and-save-file.js';
import { getFsPaths } from './fs/get-fs-paths.js';
import { join, basename, dirname, extname } from 'node:path';
import { tmpdir } from 'node:os';
import type { DatabaseUrlResult, FsPaths, Options } from './types.js';
import { GENERATED_CODE_FILENAMES } from './constants.js';
import type { ModelDefinition, Schema } from './../api/types.js';
import { getModelNames } from './parse/get-model-names.js';
import ts from 'typescript';
import fs from 'fs-extra';
import { getFile } from './fs/get-file.js';
import log from './ui/log.js';
import { fmtPath, squishWords } from './utils/formatters.js';
import { prompt } from './ui/prompt.js';
import colors from 'kleur';
import { onUserCancelled } from './ui/on-user-cancelled.js';
export const generateCode = async (
  schema: Schema,
  options: Options,
  databaseUrlResult: DatabaseUrlResult
): Promise<void> => {
  const checkDirSpinner = ora('Checking output directory').start();
  const out = getFsPaths(options.outputDirectory).absolutePath;
  await fs.ensureDir(out);
  const beforePaths = await fs.readdir(out);
  const allowedFileNames = [
    GENERATED_CODE_FILENAMES.types,
    GENERATED_CODE_FILENAMES.schema,
    GENERATED_CODE_FILENAMES.database
  ].flatMap((f) => {
    return [
      f,
      basename(f, extname(f)) + '.d.ts',
      basename(f, extname(f)) + '.js',
      basename(f, extname(f)) + '.js.map'
    ];
  });
  const unrecognized = beforePaths.filter((p) => !allowedFileNames.includes(p));
  if (unrecognized.length > 0) {
    checkDirSpinner.warn();
    log.warn([
      colors.bold('Directory not empty'),
      ...squishWords(
        `There are some unrecognized file or directory names in ${options.outputDirectory}. Continuing will remove them.`
      ).split('\n')
    ]);
    const continueInNonEmpty = await prompt<boolean>({
      type: 'confirm',
      name: 'continueInNonEmpty',
      message: `Continue?`,
      initial: false
    });
    if (!continueInNonEmpty) {
      return onUserCancelled();
    }
  } else {
    checkDirSpinner.succeed();
  }

  const spinner = ora('Generating typescript code').start();
  await fs.emptyDir(out);
  const bannerComment = `
  /**
   * Generated by Frieda on ${new Date().toUTCString()}
   * Run \`frieda g\` to re-generate.
   */
  `;
  const typesTs = getTypesTsTypescript(options, schema, bannerComment);
  const schemaTs = getSchemaTsTypescript(schema, bannerComment);
  const databaseTs = getDatabaseTsTypescript(schema, bannerComment);
  const typesPaths = getFsPaths(
    join(options.outputDirectory, GENERATED_CODE_FILENAMES.types)
  );
  const schemaPaths = getFsPaths(
    join(options.outputDirectory, GENERATED_CODE_FILENAMES.schema)
  );
  const databasePaths = getFsPaths(
    join(options.outputDirectory, GENERATED_CODE_FILENAMES.database)
  );

  await prettifyAndSaveFile(typesPaths.relativePath, typesTs, 'ts');
  await prettifyAndSaveFile(schemaPaths.relativePath, schemaTs, 'ts');
  await prettifyAndSaveFile(databasePaths.relativePath, databaseTs, 'ts');

  let outputPaths = [typesPaths, schemaPaths, databasePaths];
  if (options.compileJs) {
    spinner.text = 'Compiling to javascript';
    const program = ts.createProgram(
      [
        typesPaths.relativePath,
        schemaPaths.relativePath,
        databasePaths.relativePath
      ],
      {
        declaration: true,
        isolatedModules: true,
        preserveValueImports: true,
        lib: ['esnext'],
        moduleResolution: ts.ModuleResolutionKind.NodeNext,
        module: ts.ModuleKind.ESNext,
        target: ts.ScriptTarget.ESNext,
        allowJs: true,
        checkJs: true,
        esModuleInterop: true,
        forceConsistentCasingInFileNames: true,
        resolveJsonModule: true,
        skipLibCheck: true,
        sourceMap: true,
        strict: true
      }
    );
    program.emit();
    const jsPaths: FsPaths[] = [];
    for (const p of outputPaths) {
      const jsRelPath = join(
        p.dirname,
        basename(p.basename, p.extname) + '.js'
      );
      const tsDRelPath = join(
        p.dirname,
        basename(p.basename, p.extname) + '.d.ts'
      );
      const jsFile = await getFile(jsRelPath);
      const tsdFile = await getFile(tsDRelPath);
      await prettifyAndSaveFile(
        jsFile.relativePath,
        jsFile.contents || '',
        'js'
      );
      jsPaths.push(jsFile);
      await prettifyAndSaveFile(
        tsdFile.relativePath,
        tsdFile.contents || '',
        'ts'
      );
      jsPaths.push(tsdFile);
      await fs.rm(p.absolutePath);
    }
    outputPaths = [...jsPaths];
  }
  spinner.succeed('Code generated.');
  log.info([
    'Files:',
    ...outputPaths.map((p) => `- ${fmtPath(p.relativePath)}`)
  ]);
  const usage = [
    'Sample usage:',
    `// ${dirname(options.outputDirectory)}/your-db-code.${
      options.compileJs ? 'js' : 'ts'
    }`,
    `import { connect } from '@planetscale/database';`,
    `import { AppDb } from './${basename(
      getFsPaths(options.outputDirectory).absolutePath
    )}/database.js';`,
    `const db = new AppDb(process.env.${databaseUrlResult.databaseUrlKey});`,
    `export default db;`
  ];
  log.info(usage);
};

const getSchemaTsTypescript = (
  schema: Schema,
  bannerComment: string
): string => {
  return `
    ${bannerComment}

    import type { SchemaDefinition } from '@nowzoo/frieda';

    export const schema: SchemaDefinition = ${JSON.stringify(schema)};
  `;
};

const getTypesForModel = (m: ModelDefinition): string => {
  const names = getModelNames(m.tableName);
  return `
    /**
     * Types for the ${m.modelName} model
     */
    export type ${names.modelName} = {
      ${m.fields
        .map((f) => {
          return `${f.fieldName}${f.isInvisible ? '?' : ''}: ${
            f.javascriptType
          }${f.isNullable ? '|null' : ''};`;
        })
        .join('\n')}
    }
    export type ${names.modelOmittedBySelectAllTypeName} = [
      ${m.fields
        .filter((f) => f.isInvisible)
        .map((f) => `'${f.fieldName}'`)
        .join(',')}
    ];
    export type ${names.modelPrimaryKeyTypeName} = {
      ${m.fields
        .filter((f) => f.isPrimaryKey)
        .map((f) => {
          return `${f.fieldName}: ${f.javascriptType}`;
        })
        .join('\n')};
    }
    export type ${names.modelCreateDataTypeName} = {
      ${m.fields
        .filter((f) => !f.isAlwaysGenerated)
        .map((f) => {
          const isOptional = f.hasDefault || f.isAutoIncrement;
          return `${f.fieldName}${isOptional ? '?' : ''}: ${f.javascriptType}${
            f.isNullable ? '|null' : ''
          }`;
        })
        .join('\n')};
    }
    export type ${names.modelUpdateDataTypeName} = {
      ${m.fields
        .filter((f) => !f.isAlwaysGenerated)
        .filter((f) => !f.isPrimaryKey)
        .map((f) => {
          return `${f.fieldName}?: ${f.javascriptType}${
            f.isNullable ? '|null' : ''
          }`;
        })
        .join('\n')};
    }
    export type ${names.modelFindUniqueParamsTypeName} = ${[
    names.modelPrimaryKeyTypeName,
    ...m.fields
      .filter((f) => f.isUnique)
      .map((f) => {
        return `{${f.fieldName}: ${f.javascriptType}}`;
      })
  ].join('|')}
    export type ${names.modelDbTypeName} = ModelDb<${[
    names.modelName,
    names.modelOmittedBySelectAllTypeName,
    names.modelPrimaryKeyTypeName,
    names.modelCreateDataTypeName,
    names.modelUpdateDataTypeName,
    names.modelFindUniqueParamsTypeName
  ].join(',')}>
    
  `;
};

const getTypesTsTypescript = (
  options: Options,
  schema: Schema,
  bannerComment: string
): string => {
  return `
    ${bannerComment}
    import type { ModelDb } from '@nowzoo/frieda';
    ${(options.typeImports || []).join('\n')}

    ${schema.models.map((m) => getTypesForModel(m)).join('\n\n')}

    `;
};

const getDatabaseTsTypescript = (schema: Schema, bannerComment: string) => {
  return `
    ${bannerComment}
    import type {Transaction, Connection } from '@planetscale/database';
    import { BaseDb, ModelDb, type DbLoggingOptions } from '@nowzoo/frieda';
    import type {
      ${schema.models
        .map((m) => getModelNames(m.tableName).modelDbTypeName)
        .join(',')}
    } from './types.js'
    import { schema } from './schema.js';
    export abstract class ModelsDb extends BaseDb {
      #models: Partial<{
        ${schema.models
          .map((m) => {
            const { classGetterName, modelDbTypeName } = getModelNames(
              m.tableName
            );
            return `${classGetterName}: ${modelDbTypeName}`;
          })
          .join('\n')}
      }> = {};

      ${schema.models
        .map((m) => {
          const { classGetterName, modelDbTypeName } = getModelNames(
            m.tableName
          );

          return `
            get ${classGetterName}(): ${modelDbTypeName} {
              if (! this.#models.${classGetterName}) {
                this.#models.${classGetterName} = new ModelDb('${m.modelName}', this.connOrTx, schema, this.loggingOptions)
              }
              return this.#models.${classGetterName} 
            }
          `;
        })
        .join('\n')}
    }

    export class TxDb extends ModelsDb {
      constructor(
        transaction: Transaction,
        loggingOptions: DbLoggingOptions = {}
      ) {
        super(transaction, schema, loggingOptions)
      }
    }

    export class AppDb extends ModelsDb {
      #conn: Connection;
      constructor(
        connection: Connection,
        loggingOptions: DbLoggingOptions = {}
      ) {
        super(connection, schema, loggingOptions);
        this.#conn = connection;
      }
      async transaction<T>(txFn: (txDb: TxDb) => Promise<T>) {
        const result = await this.#conn.transaction(async (tx) => {
          const txDb = new TxDb(tx, this.loggingOptions);
          return await txFn(txDb);
        });
        return result;
      }
    }
   

    

    `;
};
