import type {
  GeneratedCode,
  RawSchema,
  ResolvedSettings
} from './types.js';
import {
  SimplifiedDatabaseType,
  type FieldSchema,
  type FullTextSearchIndex,
  type Model,
  type ModelSchema,
  type FullTextSearchIndexes
} from '../../api/shared.server.js';
import type { RawTableColumnInfo, RawTableInfo } from './types.js';
import _ from 'lodash'
import { createSpinner, formatFilePath, prettify } from './utils.js';
import fs from 'fs-extra'
import { join } from 'path';
import { log } from '@clack/prompts';
import colors from 'picocolors'
const constNames = {
  schemaCasts: 'schemaCasts',
  searchIndexes: 'searchIndexes'
};

export const generate = async (schema: RawSchema, settings: ResolvedSettings) => {
  const s = createSpinner(`Generating code`)
  const modelSchemas = getModelSchemas(schema.tables);
  const code: GeneratedCode = generateCode(modelSchemas, settings);
  await fs.ensureDir(settings.generatedCodeDirectoryFullPath);
  const filePaths = await Promise.all(
    Object.keys(code).map((key) =>
      writeFile(key, code[key as keyof GeneratedCode], settings)
    )
  );

  s.done();
  log.info(
    [
      colors.dim('Generated files:'),
      ...filePaths.map((p) => formatFilePath(p)),
      `Visit ${colors.underline(
        colors.cyan('https://github.com/nowzoo/frieda')
      )} for documentation.`
    ].join('\n')
  );
}

export const generateCode = (
  modelSchemas: ModelSchema<Model>[],
  vars: ResolvedSettings
): GeneratedCode => {
  const bannerComment = `
    /**
     * Generated by frieda on ${new Date().toUTCString()}
     * To regenerate run "frieda g"
     */
  `;
  return {
    models: getModelsCode(modelSchemas, vars, bannerComment),
    database: getDatabaseCode(modelSchemas, vars, bannerComment),
    constants: getConstantsCode(modelSchemas, bannerComment)
  };
};

const getModelsCode = (
  modelSchemas: ModelSchema<Model>[],
  vars: ResolvedSettings,
  bannerComment: string
): string => {
  const declarations: string[] = [];
  modelSchemas.forEach((m) => {
    const names = getModelNames(m);
    declarations.push('', `// Model ${m.modelName}`);
    declarations.push(`
      export type ${m.modelName} = {
        ${m.fields
          .map((f) => {
            return `${f.name}: ${f.javascriptType}${
              f.nullable ? '|null' : ''
            };`;
          })
          .join('\n')}
      }
    `);

    declarations.push(`
      export type ${names.primaryKey} =  {
        ${m.fields
          .filter((c) => c.isPrimaryKey)
          .map((c) => {
            return `${c.name}: ${c.javascriptType};`;
          })
          .join('\n')}
      }
    `);
    declarations.push(`
      export type ${names.createData} = {
        ${m.fields
          .filter((c) => {
            return !c.isGeneratedAlways;
          })
          .map((c) => {
            const optional = c.isDefaultGenerated || c.nullable;
            return `${c.name}${optional ? '?' : ''}: ${c.javascriptType};`;
          })
          .join('\n')}
      }
    `);
    declarations.push(`
      export type ${names.updateData} = {
        ${m.fields
          .filter((c) => {
            return !c.isGeneratedAlways && !c.isPrimaryKey;
          })
          .map((c) => {
            return `${c.name}?: ${c.javascriptType};`;
          })
          .join('\n')}
      }
    `);
    const uniqueDefs = m.fields
      .filter((c) => c.isUnique)
      .map((c) => `{${c.name}: ${c.javascriptType}}`);
    uniqueDefs.unshift(names.primaryKey);
    declarations.push(`
      export type ${names.findUniqueParams} = ${uniqueDefs.join('|')}
    `);
    declarations.push(`
      export type ${names.modelRepo} = ModelRepo<
      ${m.modelName},
      ${names.primaryKey},
      ${names.createData},
      ${names.updateData},
      ${names.findUniqueParams}
      >
    `);
    const def = JSON.stringify(m).replaceAll(
      /"databaseType"\s*:\s*"([^"]+)"/g,
      'databaseType:SimplifiedDatabaseType.$1'
    );
    declarations.push(`export const ${names.modelSchemaDef}:ModelSchema<${m.modelName}> = ${def}`);
  });
  return `
    ${bannerComment} 

    import { type ModelRepo, type ModelSchema, SimplifiedDatabaseType } from '@nowzoo/frieda';

    // type imports defined in .friedarc...
    ${(vars.externalTypeImports || []).join('\n')}

    ${declarations.join('\n')}
  `;
};

const getConstantsCode = (
  modelSchemas: ModelSchema<Model>[],
  bannerComment: string
): string => {
  const searchIndexes: FullTextSearchIndexes = {};
  modelSchemas
    .flatMap((m) => m.fullTextSearchIndexes)
    .forEach((index) => (searchIndexes[index.indexKey] = index));

  return `
    ${bannerComment}

    import type { SchemaCasts, FullTextSearchIndexes } from '@nowzoo/frieda';

    export const ${constNames.schemaCasts}: SchemaCasts = {
      ${modelSchemas
        .flatMap((m) => {
          return m.fields.map((f) => {
            return `'${m.tableName}.${f.name}': SimplifiedDatabaseType.${f.databaseType},`;
          });
        })
        .join('\n')}
    }

    export const ${
      constNames.searchIndexes
    }: FullTextSearchIndexes = ${JSON.stringify(searchIndexes)}
  `;
};

const getDatabaseCode = (
  modelSchemas: ModelSchema<Model>[],
  vars: ResolvedSettings,
  bannerComment: string
): string => {
  return `
    ${bannerComment}
    import { AbstractDb, ModelRepo, SimplifiedDatabaseType, type DbLoggingOptions } from '@nowzoo/frieda';
    import type {
      Connection,
      Transaction
    } from '@planetscale/database';

  

    import {
      ${modelSchemas
        .flatMap((m) => {
          const { modelRepo, modelSchemaDef } = getModelNames(m);
          return [ `type ${modelRepo}`, modelSchemaDef];
        })
        .join(',')}
    } from './models.js'
    import { ${constNames.schemaCasts} } from './constants.js';

    abstract class ModelRepos extends AbstractDb {
      private repos: Partial<{
        ${modelSchemas
          .map((m) => {
            const names = getModelNames(m);
            return `${names.classAccessor}: ${names.modelRepo};`;
          })
          .join(`\n`)}
      }> = {};
      constructor(
        connOrTx: Connection | Transaction,
        loggingOptions: DbLoggingOptions = {}
      ) {
        super(connOrTx, schemaCasts, loggingOptions)
      }
      ${modelSchemas.map((m) => {
        const names = getModelNames(m);
        return `
          get ${names.classAccessor}(): ${names.modelRepo} {
            if (! this.repos.${names.classAccessor}) {
              this.repos.${names.classAccessor} = new ModelRepo(
                ${names.modelSchemaDef},
                this.connection,
                ${constNames.schemaCasts},
                this.loggingOptions
              )
            }
            return this.repos.${names.classAccessor};
          }
        `;
      }).join('\n')}
    }
    

    class TxDb extends ModelRepos {
      constructor(
        transaction: Transaction,
        loggingOptions: DbLoggingOptions = {}
      ) {
          super(transaction, loggingOptions)
        }
      }
    

    export class AppDb extends ModelRepos {
      constructor(
        private conn: Connection,
        loggingOptions: DbLoggingOptions = {}
      ) {
          super(conn, loggingOptions)
        }
      
      async transaction<T>(txFn: (txDb: TxDb) => Promise<T>) {
        const result = await this.conn.transaction(async (tx) => {
          const txDb = new TxDb(tx, this.loggingOptions);
          return await txFn(txDb);
        });
        return result;
      }
    }
    
  `;
};

type ModelNames = {
  primaryKey: string;
  createData: string;
  updateData: string;
  findUniqueParams: string;
  modelRepo: string;
  classAccessor: string;
  modelSchemaDef: string;
};

const getModelNames = (m: ModelSchema<Model>): ModelNames => {
  return {
    primaryKey: `${m.modelName}PrimaryKey`,
    createData: `${m.modelName}CreateData`,
    updateData: `${m.modelName}UpdateData`,
    findUniqueParams: `${m.modelName}FindUniqueParams`,
    modelRepo: `${m.modelName}ModelRepo`,
    classAccessor: _.camelCase(m.modelName),
    modelSchemaDef: `${_.camelCase(m.modelName)}ModelSchema`
  };
};


export const getModelSchemas = (
  tables: RawTableInfo[]
): ModelSchema<Model>[] => {
  return tables.map((t) => createModelSchema(t));
};

const createModelSchema = (table: RawTableInfo): ModelSchema<Model> => {
  const indexNames = table.indexes.map(index => index.Key_name);
  const fields = table.columns.map((c) => createFieldSchema(c, table.name));
  return {
    modelName: _.upperFirst(_.camelCase(table.name)),
    tableName: table.name,
    fields,
    fullTextSearchIndexes: getTableFullTextSearchIndexes(table)
  };
};

const createFieldSchema = (
  column: RawTableColumnInfo,
  tableName: string
): FieldSchema<Model> => {
  const databaseType = getSimplifiedDatabaseType(column, tableName);
  const def: FieldSchema<Model> = {
    name: column.Field,
    databaseType,
    javascriptType: getJavascriptType(column, databaseType, tableName),
    hasDefault: column.Default !== null,
    isPrimaryKey: /PRI/i.test(column.Key),
    nullable: /yes/i.test(column.Null),
    isCreatedAt: false,
    isUpdatedAt: false,
    isPrimaryKeyGenerated: false,
    isDefaultGenerated: /DEFAULT_GENERATED/i.test(column.Extra),
    isGeneratedAlways:
      /STORED/i.test(column.Extra) && /GENERATED/i.test(column.Extra),
    isUnique: /UNI/i.test(column.Key)
  };
  if (def.isPrimaryKey && /auto_increment/i.test(column.Extra)) {
    def.isPrimaryKeyGenerated = true;
    def.isDefaultGenerated = true;
  }
  if (databaseType === SimplifiedDatabaseType.Date) {
    if (/DEFAULT_GENERATED/i.test(column.Extra)) {
      if (/on\s+update\s+CURRENT_TIMESTAMP/i.test(column.Extra)) {
        def.isUpdatedAt = true;
      } else {
        def.isCreatedAt = true;
      }
    }
  }
  return def;
};

const getSimplifiedDatabaseType = (
  column: RawTableColumnInfo,
  tableName: string
): SimplifiedDatabaseType => {
  // Deal with  bigint first. Assumed to be Key, unless the @bigint flag is in the comment
  if (/bigint/i.test(column.Type)) {
    return /@bigint/i.test(column.Comment)
      ? SimplifiedDatabaseType.BigInt
      : SimplifiedDatabaseType.Key;
  }
  // Deal with the other int types. Assumed to be Int, unless either @bigint or @boolean flags are present
  if (/int/i.test(column.Type)) {
    if (/@bigint/i.test(column.Comment)) {
      return SimplifiedDatabaseType.BigInt;
    }
    return /@boolean/i.test(column.Comment)
      ? SimplifiedDatabaseType.Boolean
      : SimplifiedDatabaseType.Int;
  }

  // floats...
  if (/float|double|decimal/i.test(column.Type)) {
    return SimplifiedDatabaseType.Float;
  }

  // enum...
  if (/enum/i.test(column.Type)) {
    return SimplifiedDatabaseType.Enum;
  }

  // datetime...
  if (/datetime/i.test(column.Type)) {
    return SimplifiedDatabaseType.Date;
  }

  // datetime...
  if (/json/i.test(column.Type)) {
    return SimplifiedDatabaseType.Json;
  }

  // all the string types...
  if (/text|char/i.test(column.Type)) {
    return SimplifiedDatabaseType.String;
  }

  // Out of luck for now. If we need to support other database types, add them later.
  throw new Error(
    `Unsupported database type ${column.Type} for ${tableName}.${column.Field}`
  );
};


const getJavascriptType = (
  column: RawTableColumnInfo,
  simpleType: SimplifiedDatabaseType,
  tableName: string
) => {
  if (simpleType === SimplifiedDatabaseType.Enum) {
    const result = column.Type.match(/enum\s*\(\s*([^)]+)\s*\)/i);
    if (!result) {
      throw new Error(
        `Unsupported enum type ${column.Type} for ${tableName}.${column.Field}`
      );
    }
    return result[1].split(',').join('|');
  }
  if (simpleType === SimplifiedDatabaseType.Json) {
    const result = column.Comment.match(/@jsontype\s*\(\s*([^)]+)\s*\)/i);
    return result ? result[1] : 'unknown';
  }
  switch (simpleType) {
    case SimplifiedDatabaseType.BigInt:
      return 'bigint';
    case SimplifiedDatabaseType.Int:
    case SimplifiedDatabaseType.Float:
      return 'number';
    case SimplifiedDatabaseType.Boolean:
      return 'boolean';
    case SimplifiedDatabaseType.Date:
      return 'Date';
    case SimplifiedDatabaseType.Key:
    case SimplifiedDatabaseType.String:
      return 'string';
    default:
      throw Error(
        `Could not calculate the javascript type for ${tableName}.${column.Field}`
      );
  }
};

const getTableFullTextSearchIndexes = (
  table: RawTableInfo
): FullTextSearchIndex[] => {
  const indexes: FullTextSearchIndex[] = [];
  table.indexes.forEach((rawIndex) => {
    if (!/FULLTEXT/i.test(rawIndex.Index_type)) {
      return;
    }
    const key = rawIndex.Key_name;
    let indexDef: FullTextSearchIndex | undefined = indexes.find(
      (i) => i.indexKey === key
    );
    if (indexDef) {
      indexDef.indexedFields.push(rawIndex.Column_name);
    } else {
      indexDef = {
        indexKey: key,
        indexedFields: [rawIndex.Column_name],
        tableName: table.name
      };
      indexes.push(indexDef);
    }
  });
  return indexes;
};


const writeFile = async (
  key: string,
  code: string,
  settings: ResolvedSettings
): Promise<string> => {
  const fullPath = join(settings.generatedCodeDirectoryFullPath, `${key}.ts`);

  const prettified = await prettify(code, fullPath);
  await fs.writeFile(fullPath, prettified);
  return fullPath;
};