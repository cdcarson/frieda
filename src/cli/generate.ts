import { promptMigrationsDirectory } from './shared/prompt-migrations-directory.js';
import type { FriedaVars } from './shared/types.js';
import { intro, outro, spinner, log, confirm, isCancel } from '@clack/prompts';
import { promptDatabaseUrl } from './shared/prompt-database-url.js';
import {
  getGeneratedModelsDirectoryFullPath,
  prettify
} from './shared/utils.js';
import colors from 'picocolors';
import fs from 'fs-extra';
import { cancelAndExit } from './shared/cancel-and-exit.js';
import { getMysql2Connection } from './shared/get-mysql-2-connection.js';
import { introspectShared } from './shared/introspect-shared.js';
import { getServerlessConnection } from './shared/get-serverless-connection.js';
import { join } from 'path';
import { promptGeneratedModelsDirectory } from './shared/prompt-generated-models-directory.js';
import { fetchTableInfos } from './shared/fetch-table-infos.js';
import { createModelSchemas} from './shared/create-model-schemas.js'
import type { Model, ModelSchema, FullTextSearchIndex } from '../api/shared.server.js';
import _ from 'lodash'
export const generate = async(friedaVars: FriedaVars) => {
  intro('Generate models');
  let { databaseUrl, generatedModelsDirectory, externalTypeImports } = friedaVars;
  if (typeof generatedModelsDirectory !== 'string') {
    generatedModelsDirectory = await promptGeneratedModelsDirectory(friedaVars);
  }
  if (typeof databaseUrl !== 'string') {
    databaseUrl = await promptDatabaseUrl(friedaVars);
  }
  
  const s = spinner();
  s.start('Generating models')
  const modelsPath = getGeneratedModelsDirectoryFullPath(generatedModelsDirectory);
  const tableInfos = await fetchTableInfos(getServerlessConnection(databaseUrl));
  const schema = createModelSchemas(tableInfos);
  const bannerComment = `
  /**
   * Generated by frieda on ${new Date().toUTCString()}
   * To regenerate run "frieda g"
   */
  `
  const modelsSharedPath = join(modelsPath, 'models.shared.ts')
  const searchIndexesPath = join(modelsPath, 'search-indexes.server.ts')
  const dbPath = join(modelsPath, 'db.server.ts')
  const modelsSharedTs = await prettify(getModelsSharedTs(schema, externalTypeImports|| [],bannerComment), modelsSharedPath);
  const searchIndexesTs = await prettify(getSearchIndexesServerTs(schema, bannerComment), searchIndexesPath);
  const dbTs = (geDbServerTs(schema, externalTypeImports|| [], bannerComment), dbPath);
  await fs.ensureDir(modelsPath);
  await fs.writeFile(modelsSharedPath, modelsSharedTs)
  await fs.writeFile(searchIndexesPath, searchIndexesTs)
  await fs.writeFile(dbPath, dbTs)

  s.stop('Models genertaed');
  outro('Done.')
}

const getModelsSharedTs = (modelDefs: ModelSchema<Model>[], externalTypeImports: string[], bannerComment: string): string => {
  const defs = modelDefs.map((m) => {
    const cols = m.fields.map((f) => {
      return `${f.name}: ${f.javascriptType}${f.nullable ? '|null' : ''};`;
    });
    return ` export type ${m.modelName} = {
      ${cols.join('\n')}
    }`;
  });
  return `
  ${bannerComment}

  ${externalTypeImports.join('\n')}

  ${defs.join(`\n\n`)}
  `;
};

export const getSearchIndexesServerTs = (
  modelDefs: ModelSchema<Model>[], bannerComment: string
): string => {
  const indexes = modelDefs.flatMap((m) => m.fullTextSearchIndexes);
  const mappedIndexes: { [key: string]: FullTextSearchIndex } = {};
  indexes.forEach((index) => (mappedIndexes[index.indexKey] = index));
  return `
    ${bannerComment}
    import type { FullTextSearchIndex } from '@nowzoo/frieda';
    export const searchIndexes: {[key: string]: FullTextSearchIndex} = ${JSON.stringify(
      mappedIndexes
    )}
  `;
};

const geDbServerTs = (modelDefs: ModelSchema<Model>[], externalTypeImports: string[], bannerComment: string): string => {


  type RepoInfo = {
    modelName: string;
    tableName: string;
    classRepoName: string;
    classGetter: string;
    repoDef: { name: string; def: ModelSchema<Model> };
    primary: { typeName: string; typeDef: string };
    create: { typeName: string; typeDef: string };
    update: { typeName: string; typeDef: string };
    unique: { typeName: string; typeDef: string };
    repo: { typeName: string; typeDef: string };
  };
  const infos: RepoInfo[] = modelDefs.map((m) => {
    const classRepoName = `${_.camelCase(m.modelName)}`;
    const repoDefName = `${classRepoName}RepoDefinition`;
    const primaryKeyTypeName = `${m.modelName}PrimaryKey`;
    const createDataTypeName = `${m.modelName}CreateData`;
    const updateDataTypeName = `${m.modelName}UpdateData`;
    const findUniqueParamsTypeName = `${m.modelName}FindUniqueParams`;
    const repoTypeName = `${m.modelName}Repo`;
    const repoTypeDef = `Repo<${m.modelName}, ${primaryKeyTypeName}, ${createDataTypeName}, ${updateDataTypeName}, ${findUniqueParamsTypeName}>`;

    const classGetter = `get ${classRepoName}():${repoTypeName} {
      if (! this.repos.${classRepoName}) {
        this.repos.${classRepoName} = new Repo(${repoDefName}, this.connection)
      }
      return this.repos.${classRepoName};
    }`;
    const primaryKeyTypeDef = `
      {
        ${m.fields
          .filter((c) => c.isPrimaryKey)
          .map((c) => {
            return `${c.name}: ${c.javascriptType};`;
          })
          .join('\n')}
      }
    `;
    const createTypeDef = `
      {
        ${m.fields
          .filter((c) => {
            return !c.isGeneratedAlways;
          })
          .map((c) => {
            const optional = c.isDefaultGenerated || c.nullable;
            return `${c.name}${optional ? '?' : ''}: ${c.javascriptType};`;
          })
          .join('\n')}
        
       
      }
    `;
    const updateTypeDef = `
      {
        ${m.fields
          .filter((c) => {
            return !c.isGeneratedAlways && !c.isPrimaryKey;
          })
          .map((c) => {
            return `${c.name}?: ${c.javascriptType};`;
          })
          .join('\n')}
        
       
      }
    `;
    const uniqueDefs = m.fields
      .filter((c) => c.isUnique)
      .map((c) => `{${c.name}: ${c.javascriptType}}`);
    uniqueDefs.unshift(primaryKeyTypeName);
    const findUniqueParamsTypeDef = uniqueDefs.join('|');

    return {
      modelName: m.modelName,
      tableName: m.tableName,
      classRepoName,
      classGetter,
      primary: { typeName: primaryKeyTypeName, typeDef: primaryKeyTypeDef },
      create: { typeName: createDataTypeName, typeDef: createTypeDef },
      update: { typeName: updateDataTypeName, typeDef: updateTypeDef },
      unique: {
        typeName: findUniqueParamsTypeName,
        typeDef: findUniqueParamsTypeDef
      },
      repoDef: { name: repoDefName, def: m },
      repo: { typeName: repoTypeName, typeDef: repoTypeDef }
    };
  });
  const types = infos
    .map((info) => {
      return `
      /** 
       * ${info.modelName}  
       */
      export type ${info.primary.typeName} = ${info.primary.typeDef}
      export type ${info.create.typeName} = ${info.create.typeDef}
      export type ${info.update.typeName} = ${info.update.typeDef}
      export type ${info.unique.typeName} = ${info.unique.typeDef}
      export type ${info.repo.typeName} = ${info.repo.typeDef}
      export const ${info.repoDef.name}: RepoDefinition<${
        info.modelName
      }> = ${JSON.stringify(info.repoDef.def)}

    `;
    })
    .join('\n\n');

  const classDef = `
    export abstract class AbstractAppDb extends AbstractDb {
      private repos: Partial<{${infos
        .map((info) => `${info.classRepoName}: ${info.repo.typeName}`)
        .join('\n')}}> = {};

      ${infos.map((info) => info.classGetter).join('\n')}
    }
  `;

  return `
    ${bannerComment}
    import { AbstractDb } from '@nowzoo/frieda';
    import { Repo } from '../classes/crud-repo.server.js';
    ${externalTypeImports.join('\n')}
    import type {
      ${modelDefs.map((m) => m.modelName).join(',')}
    } from './models.shared.js'

    ${types}

    
  `;
};
